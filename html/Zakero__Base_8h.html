<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zakero&#39;s C++ Header Libraries: Zakero_Base.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Zakero&#39;s C++ Header Libraries
   </div>
   <div id="projectbrief">A collection of reusable C++ libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Zakero_Base.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Zakero Base.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
Include dependency graph for Zakero_Base.h:</div>
<div class="dyncontent">
<div class="center"><img src="Zakero__Base_8h__incl.png" border="0" usemap="#aZakero__Base_8h" alt=""/></div>
<map name="aZakero__Base_8h" id="aZakero__Base_8h">
<area shape="rect" title="Zakero Base." alt="" coords="186,5,305,31"/>
<area shape="rect" title=" " alt="" coords="5,79,72,104"/>
<area shape="rect" title=" " alt="" coords="96,79,157,104"/>
<area shape="rect" title=" " alt="" coords="181,79,232,104"/>
<area shape="rect" title=" " alt="" coords="256,79,315,104"/>
<area shape="rect" title=" " alt="" coords="339,79,463,104"/>
<area shape="rect" title=" " alt="" coords="487,79,550,104"/>
</map>
</div>
</div>
<p><a href="Zakero__Base_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac4101606c3023aeea0ce4be3000111c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#ac4101606c3023aeea0ce4be3000111c4">ZAKERO_CONCAT</a>(thing_1_,  thing_2_)</td></tr>
<tr class="memdesc:ac4101606c3023aeea0ce4be3000111c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the two things.  <br /></td></tr>
<tr class="separator:ac4101606c3023aeea0ce4be3000111c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79e34323a85453ec650c1685790fb86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#ac79e34323a85453ec650c1685790fb86">ZAKERO_DELETE</a>(ptr_)</td></tr>
<tr class="memdesc:ac79e34323a85453ec650c1685790fb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete memory.  <br /></td></tr>
<tr class="separator:ac79e34323a85453ec650c1685790fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f8b2acde372250a96dbf6f61a3cacf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#ab9f8b2acde372250a96dbf6f61a3cacf">ZAKERO_DISABLE_IMPLICIT_CASTS</a>(func_name_)</td></tr>
<tr class="memdesc:ab9f8b2acde372250a96dbf6f61a3cacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't allow implicit parameter conversion.  <br /></td></tr>
<tr class="separator:ab9f8b2acde372250a96dbf6f61a3cacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2681d544bba218e96ae5d935973351d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a2681d544bba218e96ae5d935973351d0">ZAKERO_FREE</a>(ptr_)</td></tr>
<tr class="memdesc:a2681d544bba218e96ae5d935973351d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory.  <br /></td></tr>
<tr class="separator:a2681d544bba218e96ae5d935973351d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99deb7deff3d96a3b10be310af05992"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#ac99deb7deff3d96a3b10be310af05992">ZAKERO_MACRO_HAS_VALUE</a>(define_)</td></tr>
<tr class="memdesc:ac99deb7deff3d96a3b10be310af05992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a macro has a value.  <br /></td></tr>
<tr class="separator:ac99deb7deff3d96a3b10be310af05992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae215a7260edaa592d797ba542af7e693"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#ae215a7260edaa592d797ba542af7e693">ZAKERO_PID</a></td></tr>
<tr class="memdesc:ae215a7260edaa592d797ba542af7e693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Process Id.  <br /></td></tr>
<tr class="separator:ae215a7260edaa592d797ba542af7e693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c1e2f02eaa23a6e921ba4ec7b76e20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a08c1e2f02eaa23a6e921ba4ec7b76e20">ZAKERO_STEADY_TIME_NOW</a>(unit_)</td></tr>
<tr class="memdesc:a08c1e2f02eaa23a6e921ba4ec7b76e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current time.  <br /></td></tr>
<tr class="separator:a08c1e2f02eaa23a6e921ba4ec7b76e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc833658760df994f6a931fc43f45cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a0cc833658760df994f6a931fc43f45cf">ZAKERO_SYSTEM_TIME_NOW</a>(unit_)</td></tr>
<tr class="memdesc:a0cc833658760df994f6a931fc43f45cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current time.  <br /></td></tr>
<tr class="separator:a0cc833658760df994f6a931fc43f45cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857ff037307c945ad03e3a8e20c31ad6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a857ff037307c945ad03e3a8e20c31ad6">ZAKERO_UNUSED</a>(var_)</td></tr>
<tr class="memdesc:a857ff037307c945ad03e3a8e20c31ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent "unused variable" compilier warnings.  <br /></td></tr>
<tr class="separator:a857ff037307c945ad03e3a8e20c31ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a91527d290403cbcf2e34f76e34ae09b9"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a> : uint64_t { <br />
&#160;&#160;<a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9aa245c3230debe5c956484ecc6fa93877">Byte</a>
, <br />
&#160;&#160;<a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9ade082b87d805e72ea179a7dfd2633de9">Kilobyte</a>
, <br />
&#160;&#160;<a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9a4d9ecdaacb52c86594242e5f041a6c59">Megabyte</a>
, <br />
&#160;&#160;<a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9a216c9b2bcd6ad84ac05cc369bb629a8b">Gigabyte</a>
, <br />
&#160;&#160;<a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9a6940c7a6618d362b74d0d2cc217dc72a">Terabyte</a>
, <br />
&#160;&#160;<a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9ada7cc490ff46720d25f4944a4a9ad1a5">Petabyte</a>
, <br />
&#160;&#160;<a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9a79d4b4563d1c6300b5021351d418eeea">Exabyte</a>
<br />
 }</td></tr>
<tr class="memdesc:a91527d290403cbcf2e34f76e34ae09b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion Type.  <a href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">More...</a><br /></td></tr>
<tr class="separator:a91527d290403cbcf2e34f76e34ae09b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acd4811517bd583f0162299b959698e3b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#acd4811517bd583f0162299b959698e3b">zakero::convert</a> (const double size, const <a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a> from, const <a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a> to) noexcept</td></tr>
<tr class="memdesc:acd4811517bd583f0162299b959698e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert storage sizes.  <br /></td></tr>
<tr class="separator:acd4811517bd583f0162299b959698e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eb17866baa07bf3529c1229deee575"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#ab6eb17866baa07bf3529c1229deee575">zakero::convert</a> (const uint64_t size, const <a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a> from, const <a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a> to) noexcept</td></tr>
<tr class="memdesc:ab6eb17866baa07bf3529c1229deee575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert storage sizes.  <br /></td></tr>
<tr class="separator:ab6eb17866baa07bf3529c1229deee575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace975103ee10232efb16983c71a3ab12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#ace975103ee10232efb16983c71a3ab12">zakero::equalish</a> (const float a, const float b, const float delta) noexcept</td></tr>
<tr class="memdesc:ace975103ee10232efb16983c71a3ab12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two floats.  <br /></td></tr>
<tr class="separator:ace975103ee10232efb16983c71a3ab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84a5062073930d2199ac90238ca2c7a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#af84a5062073930d2199ac90238ca2c7a">zakero::join</a> (std::vector&lt; std::string &gt; vector_string, const std::string_view delimiter) noexcept</td></tr>
<tr class="memdesc:af84a5062073930d2199ac90238ca2c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a collection of strings into a single string.  <br /></td></tr>
<tr class="separator:af84a5062073930d2199ac90238ca2c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5978a7bbb78921ec03207e2497c140fa"><td class="memTemplParams" colspan="2">template&lt;class Key , class Value &gt; </td></tr>
<tr class="memitem:a5978a7bbb78921ec03207e2497c140fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Key &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a5978a7bbb78921ec03207e2497c140fa">zakero::mapKeys</a> (const std::map&lt; Key, Value &gt; &amp;map) noexcept</td></tr>
<tr class="memdesc:a5978a7bbb78921ec03207e2497c140fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the keys in a map.  <br /></td></tr>
<tr class="separator:a5978a7bbb78921ec03207e2497c140fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2acc98326c47f46f52fa1bdb4c68bef"><td class="memTemplParams" colspan="2">template&lt;class Key , class Value &gt; </td></tr>
<tr class="memitem:aa2acc98326c47f46f52fa1bdb4c68bef"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Key &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#aa2acc98326c47f46f52fa1bdb4c68bef">zakero::mapKeys</a> (const std::unordered_map&lt; Key, Value &gt; &amp;map) noexcept</td></tr>
<tr class="memdesc:aa2acc98326c47f46f52fa1bdb4c68bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the keys in a map.  <br /></td></tr>
<tr class="separator:aa2acc98326c47f46f52fa1bdb4c68bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33d5dbd1487acfa96d0febe96f1f901"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#ad33d5dbd1487acfa96d0febe96f1f901">operator&lt;&lt;</a> (std::ostream &amp;stream, const std::error_code &amp;error) noexcept</td></tr>
<tr class="memdesc:ad33d5dbd1487acfa96d0febe96f1f901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert std::error_code into an output stream.  <br /></td></tr>
<tr class="separator:ad33d5dbd1487acfa96d0febe96f1f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c33f11940ead5652e83bb7c27acde1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#ad5c33f11940ead5652e83bb7c27acde1">zakero::split</a> (const std::string_view string, const std::string_view delimiter) noexcept</td></tr>
<tr class="memdesc:ad5c33f11940ead5652e83bb7c27acde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into smaller strings.  <br /></td></tr>
<tr class="separator:ad5c33f11940ead5652e83bb7c27acde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b16f691dda437260812968d8a79b3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a18b16f691dda437260812968d8a79b3b">zakero::stob</a> (const std::string_view str) noexcept</td></tr>
<tr class="memdesc:a18b16f691dda437260812968d8a79b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string into a boolean value.  <br /></td></tr>
<tr class="separator:a18b16f691dda437260812968d8a79b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0614fd99c6eb09a4c86ba1de0a214f35"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a0614fd99c6eb09a4c86ba1de0a214f35">zakero::to_string</a> (const bool value) noexcept</td></tr>
<tr class="memdesc:a0614fd99c6eb09a4c86ba1de0a214f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a bool into a string.  <br /></td></tr>
<tr class="separator:a0614fd99c6eb09a4c86ba1de0a214f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69db77331b1ac868a2f7400f1e119fc3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a69db77331b1ac868a2f7400f1e119fc3">zakero::to_string</a> (const std::error_code &amp;error) noexcept</td></tr>
<tr class="memdesc:a69db77331b1ac868a2f7400f1e119fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an std::error_code to a std::string.  <br /></td></tr>
<tr class="separator:a69db77331b1ac868a2f7400f1e119fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d6f0c9fbcb578035b681dba751d87d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a81d6f0c9fbcb578035b681dba751d87d">zakero::to_string</a> (std::chrono::nanoseconds nanoseconds) noexcept</td></tr>
<tr class="memdesc:a81d6f0c9fbcb578035b681dba751d87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert nanoseconds into a string.  <br /></td></tr>
<tr class="separator:a81d6f0c9fbcb578035b681dba751d87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2e6c7068a258d81fb0371f3d0e3063"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#adb2e6c7068a258d81fb0371f3d0e3063">zakero::tolower</a> (std::string str) noexcept</td></tr>
<tr class="memdesc:adb2e6c7068a258d81fb0371f3d0e3063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to lower case.  <br /></td></tr>
<tr class="separator:adb2e6c7068a258d81fb0371f3d0e3063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa939a096886f8989f7abb8b11c49ea81"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:aa939a096886f8989f7abb8b11c49ea81"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#aa939a096886f8989f7abb8b11c49ea81">zakero::vectorContains</a> (const std::vector&lt; Type &gt; &amp;vector, const Type &amp;value) noexcept</td></tr>
<tr class="memdesc:aa939a096886f8989f7abb8b11c49ea81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the contents of a std::vector.  <br /></td></tr>
<tr class="separator:aa939a096886f8989f7abb8b11c49ea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecded82e6c814381525228ff6cc78e1"><td class="memTemplParams" colspan="2">template&lt;class InputIter , class Type &gt; </td></tr>
<tr class="memitem:a7ecded82e6c814381525228ff6cc78e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a7ecded82e6c814381525228ff6cc78e1">zakero::vectorContains</a> (InputIter first, InputIter last, const Type &amp;value) noexcept</td></tr>
<tr class="memdesc:a7ecded82e6c814381525228ff6cc78e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the contents of a std::vector.  <br /></td></tr>
<tr class="separator:a7ecded82e6c814381525228ff6cc78e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e48d2dfbdcb280dfb6324fad096f6d"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a64e48d2dfbdcb280dfb6324fad096f6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a64e48d2dfbdcb280dfb6324fad096f6d">zakero::vectorErase</a> (std::vector&lt; Type &gt; &amp;vector, const Type &amp;value) noexcept</td></tr>
<tr class="memdesc:a64e48d2dfbdcb280dfb6324fad096f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the contents of a std::vector.  <br /></td></tr>
<tr class="separator:a64e48d2dfbdcb280dfb6324fad096f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbb9c0e79fdc0ee2a902264291aa4fe"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a5fbb9c0e79fdc0ee2a902264291aa4fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Zakero__Base_8h.html#a5fbb9c0e79fdc0ee2a902264291aa4fe">zakero::vectorErase</a> (std::vector&lt; Type &gt; &amp;vector, typename std::vector&lt; Type &gt;::iterator iter) noexcept</td></tr>
<tr class="memdesc:a5fbb9c0e79fdc0ee2a902264291aa4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the contents of a std::vector.  <br /></td></tr>
<tr class="separator:a5fbb9c0e79fdc0ee2a902264291aa4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Nothing complicated here, just a collection of helper functions, macros, and templates that may be useful in your projects.</p>
<p>Include this header in your source code to use these features.</p>
<p><a class="anchor" id="zakero_base_vers"></a></p><dl class="section user"><dt>Version</dt><dd><p class="startdd"><b>v0.9.5</b></p><ul>
<li>Added join()</li>
<li>Added mapKeys()</li>
<li>Added split()</li>
</ul>
<p class="interdd"><b>v0.9.4</b></p><ul>
<li>Added <a class="el" href="Zakero__Base_8h.html#ab9f8b2acde372250a96dbf6f61a3cacf" title="Don&#39;t allow implicit parameter conversion.">ZAKERO_DISABLE_IMPLICIT_CASTS()</a></li>
</ul>
<p class="interdd"><b>v0.9.3</b></p><ul>
<li>Added stob()</li>
<li>Added tolower()</li>
<li>Added to_string(const bool)</li>
<li>Added to_string(std::chrono::nanoseconds nanoseconds)</li>
</ul>
<p class="interdd"><b>v0.9.2</b></p><ul>
<li>Added to_string(std::error_code)</li>
<li>Added operator&lt;&lt;(std::ostream&amp;, std::error_code)</li>
<li>Added <a class="el" href="Zakero__Base_8h.html#ac79e34323a85453ec650c1685790fb86" title="Delete memory.">ZAKERO_DELETE()</a></li>
<li>Added <a class="el" href="Zakero__Base_8h.html#a2681d544bba218e96ae5d935973351d0" title="Free memory.">ZAKERO_FREE()</a></li>
<li>Added <a class="el" href="Zakero__Base_8h.html#a857ff037307c945ad03e3a8e20c31ad6" title="Prevent &quot;unused variable&quot; compilier warnings.">ZAKERO_UNUSED()</a></li>
<li>Added ZAKERO_PID</li>
<li>Added equalish()</li>
</ul>
<p class="interdd"><b>v0.9.1</b></p><ul>
<li>Added macro <a class="el" href="Zakero__Base_8h.html#a08c1e2f02eaa23a6e921ba4ec7b76e20" title="Get the current time.">ZAKERO_STEADY_TIME_NOW()</a></li>
<li>Added macro <a class="el" href="Zakero__Base_8h.html#a0cc833658760df994f6a931fc43f45cf" title="Get the current time.">ZAKERO_SYSTEM_TIME_NOW()</a></li>
<li>Added vectorErase()</li>
</ul>
<p class="enddd"><b>v0.9.0</b></p><ul>
<li>The initial collection </li>
</ul>
</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd><a href="https://www.mozilla.org/en-US/MPL/2.0/">Mozilla Public License v2</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Andrew "Zakero" Moore<ul>
<li>Original Author </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac4101606c3023aeea0ce4be3000111c4" name="ac4101606c3023aeea0ce4be3000111c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4101606c3023aeea0ce4be3000111c4">&#9670;&#160;</a></span>ZAKERO_CONCAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZAKERO_CONCAT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thing_1_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thing_2_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the C/C++ Preprocessor to create a new symbol name. For example the symbol <em>abcxyz</em> could be created using <em><a class="el" href="Zakero__Base_8h.html#ac4101606c3023aeea0ce4be3000111c4" title="Concatenate the two things.">ZAKERO_CONCAT(abc, xyz)</a></em>.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> foobar = 1;</div>
<div class="line"><a class="code hl_define" href="Zakero__Base_8h.html#ac4101606c3023aeea0ce4be3000111c4">ZAKERO_CONCAT</a>(foo, bar)++; <span class="comment">// foobar == 2</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_define" href="Zakero__Base_8h.html#ac4101606c3023aeea0ce4be3000111c4">ZAKERO_CONCAT</a>(magic_, 42) = 123;</div>
<div class="line"><span class="comment">// int magic_42 = 123;</span></div>
<div class="ttc" id="aZakero__Base_8h_html_ac4101606c3023aeea0ce4be3000111c4"><div class="ttname"><a href="Zakero__Base_8h.html#ac4101606c3023aeea0ce4be3000111c4">ZAKERO_CONCAT</a></div><div class="ttdeci">#define ZAKERO_CONCAT(thing_1_, thing_2_)</div><div class="ttdoc">Concatenate the two things.</div><div class="ttdef"><b>Definition:</b> Zakero_Base.h:114</div></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thing_1_</td><td>Symbol left side </td></tr>
    <tr><td class="paramname">thing_2_</td><td>Symbol right side </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac79e34323a85453ec650c1685790fb86" name="ac79e34323a85453ec650c1685790fb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79e34323a85453ec650c1685790fb86">&#9670;&#160;</a></span>ZAKERO_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZAKERO_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Using this macro will help catch instances of using a pointer after delete'ing the new'ed memory. It does this by setting the value of <code>ptr_</code> to <code>nullptr</code> after calling <code>delete</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr_</td><td>The value to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>++p</code> and <code>p++</code> syntax should work: <blockquote class="doxtable">
<p>&zwj;ZAKERO_DELETE(p++); ZAKERO_DELETE(p++); </p>
</blockquote>
</dd></dl>

</div>
</div>
<a id="ab9f8b2acde372250a96dbf6f61a3cacf" name="ab9f8b2acde372250a96dbf6f61a3cacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f8b2acde372250a96dbf6f61a3cacf">&#9670;&#160;</a></span>ZAKERO_DISABLE_IMPLICIT_CASTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZAKERO_DISABLE_IMPLICIT_CASTS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func_name_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When passing a value to a function's parameter which does not have a matching type, the compiler will try to inject code to convert the value into the function's expected type. Usually, this is fine. But in some instances can lead to very subtle bugs not to mention the possible minor hit in performance. Placing the function name in this macro will prevent the compiler from doing this automatic type conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_name_</td><td>The name of the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2681d544bba218e96ae5d935973351d0" name="a2681d544bba218e96ae5d935973351d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2681d544bba218e96ae5d935973351d0">&#9670;&#160;</a></span>ZAKERO_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZAKERO_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Using this macro will help catch instances of using a pointer after free'ing the memory. It does this by setting the value of <code>ptr_</code> to <code>nullptr</code> after calling free().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr_</td><td>The value to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>++p</code> and <code>p++</code> syntax should work: <blockquote class="doxtable">
<p>&zwj;ZAKERO_FREE(p++); ZAKERO_FREE(p++); </p>
</blockquote>
</dd></dl>

</div>
</div>
<a id="ac99deb7deff3d96a3b10be310af05992" name="ac99deb7deff3d96a3b10be310af05992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99deb7deff3d96a3b10be310af05992">&#9670;&#160;</a></span>ZAKERO_MACRO_HAS_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZAKERO_MACRO_HAS_VALUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">define_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this macro function to determine if a macro has a value and is not just defined.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#define BEER</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if ZAKERO_MACRO_HAS_VALUE(BEER)</span></div>
<div class="line"><span class="preprocessor">#warning I can has beer!</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#error No beer! </span><span class="comment">// &lt;-- This happens</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">define_</td><td>The defined macro to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae215a7260edaa592d797ba542af7e693" name="ae215a7260edaa592d797ba542af7e693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae215a7260edaa592d797ba542af7e693">&#9670;&#160;</a></span>ZAKERO_PID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZAKERO_PID</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the ID of the current process.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;My PID is &quot;</span> &lt;&lt; std::to_string(<a class="code hl_define" href="Zakero__Base_8h.html#ae215a7260edaa592d797ba542af7e693">ZAKERO_PID</a>) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="ttc" id="aZakero__Base_8h_html_ae215a7260edaa592d797ba542af7e693"><div class="ttname"><a href="Zakero__Base_8h.html#ae215a7260edaa592d797ba542af7e693">ZAKERO_PID</a></div><div class="ttdeci">#define ZAKERO_PID</div><div class="ttdoc">Get the Process Id.</div><div class="ttdef"><b>Definition:</b> Zakero_Base.h:219</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Process Id (<code>pid_t</code>)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>POSIX.1-2008 </dd></dl>

</div>
</div>
<a id="a08c1e2f02eaa23a6e921ba4ec7b76e20" name="a08c1e2f02eaa23a6e921ba4ec7b76e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c1e2f02eaa23a6e921ba4ec7b76e20">&#9670;&#160;</a></span>ZAKERO_STEADY_TIME_NOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZAKERO_STEADY_TIME_NOW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">unit_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro will get the current time count of the <code>std::chrono::steady_clock</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>std::chrono</code> namespace is automatically prepended to the <code>unit_</code>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> time_now = <a class="code hl_define" href="Zakero__Base_8h.html#a08c1e2f02eaa23a6e921ba4ec7b76e20">ZAKERO_STEADY_TIME_NOW</a>(milliseconds);</div>
<div class="ttc" id="aZakero__Base_8h_html_a08c1e2f02eaa23a6e921ba4ec7b76e20"><div class="ttname"><a href="Zakero__Base_8h.html#a08c1e2f02eaa23a6e921ba4ec7b76e20">ZAKERO_STEADY_TIME_NOW</a></div><div class="ttdeci">#define ZAKERO_STEADY_TIME_NOW(unit_)</div><div class="ttdoc">Get the current time.</div><div class="ttdef"><b>Definition:</b> Zakero_Base.h:238</div></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit_</td><td>The time unit to get. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cc833658760df994f6a931fc43f45cf" name="a0cc833658760df994f6a931fc43f45cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc833658760df994f6a931fc43f45cf">&#9670;&#160;</a></span>ZAKERO_SYSTEM_TIME_NOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZAKERO_SYSTEM_TIME_NOW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">unit_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro will get the current time count of the <code>std::chrono::system_clock</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>std::chrono</code> namespace is automatically prepended to the <code>unit_</code>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> time_now = <a class="code hl_define" href="Zakero__Base_8h.html#a0cc833658760df994f6a931fc43f45cf">ZAKERO_SYSTEM_TIME_NOW</a>(milliseconds);</div>
<div class="ttc" id="aZakero__Base_8h_html_a0cc833658760df994f6a931fc43f45cf"><div class="ttname"><a href="Zakero__Base_8h.html#a0cc833658760df994f6a931fc43f45cf">ZAKERO_SYSTEM_TIME_NOW</a></div><div class="ttdeci">#define ZAKERO_SYSTEM_TIME_NOW(unit_)</div><div class="ttdoc">Get the current time.</div><div class="ttdef"><b>Definition:</b> Zakero_Base.h:259</div></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit_</td><td>The time unit to get. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a857ff037307c945ad03e3a8e20c31ad6" name="a857ff037307c945ad03e3a8e20c31ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857ff037307c945ad03e3a8e20c31ad6">&#9670;&#160;</a></span>ZAKERO_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZAKERO_UNUSED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var_</td><td>The "unused variable". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a91527d290403cbcf2e34f76e34ae09b9" name="a91527d290403cbcf2e34f76e34ae09b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91527d290403cbcf2e34f76e34ae09b9">&#9670;&#160;</a></span>Storage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum struct <a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a> : uint64_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sizes in powers of 2. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a91527d290403cbcf2e34f76e34ae09b9aa245c3230debe5c956484ecc6fa93877" name="a91527d290403cbcf2e34f76e34ae09b9aa245c3230debe5c956484ecc6fa93877"></a>Byte&#160;</td><td class="fielddoc"><p>1 byte </p>
</td></tr>
<tr><td class="fieldname"><a id="a91527d290403cbcf2e34f76e34ae09b9ade082b87d805e72ea179a7dfd2633de9" name="a91527d290403cbcf2e34f76e34ae09b9ade082b87d805e72ea179a7dfd2633de9"></a>Kilobyte&#160;</td><td class="fielddoc"><p>1024 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a91527d290403cbcf2e34f76e34ae09b9a4d9ecdaacb52c86594242e5f041a6c59" name="a91527d290403cbcf2e34f76e34ae09b9a4d9ecdaacb52c86594242e5f041a6c59"></a>Megabyte&#160;</td><td class="fielddoc"><p>1024 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a91527d290403cbcf2e34f76e34ae09b9a216c9b2bcd6ad84ac05cc369bb629a8b" name="a91527d290403cbcf2e34f76e34ae09b9a216c9b2bcd6ad84ac05cc369bb629a8b"></a>Gigabyte&#160;</td><td class="fielddoc"><p>1024 megabytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a91527d290403cbcf2e34f76e34ae09b9a6940c7a6618d362b74d0d2cc217dc72a" name="a91527d290403cbcf2e34f76e34ae09b9a6940c7a6618d362b74d0d2cc217dc72a"></a>Terabyte&#160;</td><td class="fielddoc"><p>1024 gigabytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a91527d290403cbcf2e34f76e34ae09b9ada7cc490ff46720d25f4944a4a9ad1a5" name="a91527d290403cbcf2e34f76e34ae09b9ada7cc490ff46720d25f4944a4a9ad1a5"></a>Petabyte&#160;</td><td class="fielddoc"><p>1024 terabytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a91527d290403cbcf2e34f76e34ae09b9a79d4b4563d1c6300b5021351d418eeea" name="a91527d290403cbcf2e34f76e34ae09b9a79d4b4563d1c6300b5021351d418eeea"></a>Exabyte&#160;</td><td class="fielddoc"><p>1024 petabytes </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acd4811517bd583f0162299b959698e3b" name="acd4811517bd583f0162299b959698e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4811517bd583f0162299b959698e3b">&#9670;&#160;</a></span>convert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double zakero::convert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion from one storage unit to another is handled by this method. These storage units are in powers of 2.</p>
<p>The difference between this method and <a class="el" href="Zakero__Base_8h.html#ab6eb17866baa07bf3529c1229deee575" title="Convert storage sizes.">zakero::convert(const 
uint64_t, const zakero::Storage, const zakero::Storage)</a> is that conversions to a larger unit will be a fraction.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">double</span> bytes = zakero::convert(<span class="keywordtype">double</span>(16)</div>
<div class="line">        , zakero::Storage::Gigabyte</div>
<div class="line">        , zakero::Storage::Byte</div>
<div class="line">        );</div>
<div class="line"><span class="keywordtype">double</span> megs = zakero::convert(<span class="keywordtype">double</span>(16)</div>
<div class="line">        , zakero::Storage::Kilobyte</div>
<div class="line">        , zakero::Storage::Megabyte</div>
<div class="line">        );</div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The converted value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to convert</td></tr>
    <tr><td class="paramname">from</td><td>The source unit</td></tr>
    <tr><td class="paramname">to</td><td>The destination unit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6eb17866baa07bf3529c1229deee575" name="ab6eb17866baa07bf3529c1229deee575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6eb17866baa07bf3529c1229deee575">&#9670;&#160;</a></span>convert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t zakero::convert </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Zakero__Base_8h.html#a91527d290403cbcf2e34f76e34ae09b9">zakero::Storage</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion from one storage unit to another is handled by this method. These storage units are in powers of 2.</p>
<p>Converting to a larger size is rounded down and may result in <code>0</code> if the from <code>size</code> is not large enough.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">uint64_t bytes = zakero::convert(uint64_t(16)</div>
<div class="line">        , zakero::Storage::Gigabyte</div>
<div class="line">        , zakero::Storage::Byte</div>
<div class="line">        );</div>
<div class="line"> </div>
<div class="line">uint64_t megs = zakero::convert(uint64_t(16)</div>
<div class="line">        , zakero::Storage::Kilobyte</div>
<div class="line">        , zakero::Storage::Megabyte</div>
<div class="line">        );</div>
<div class="line"><span class="comment">// megs == 0</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The converted value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to convert</td></tr>
    <tr><td class="paramname">from</td><td>The source unit</td></tr>
    <tr><td class="paramname">to</td><td>The destination unit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace975103ee10232efb16983c71a3ab12" name="ace975103ee10232efb16983c71a3ab12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace975103ee10232efb16983c71a3ab12">&#9670;&#160;</a></span>equalish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zakero::equalish </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two floats for some degree of equality. For the float values to be considered "equal", the difference between the values must be less than the specified <code>delta</code>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The values are equal </td></tr>
    <tr><td class="paramname">false</td><td>The values are not equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first value</td></tr>
    <tr><td class="paramname">b</td><td>The second value</td></tr>
    <tr><td class="paramname">delta</td><td>The maximum difference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af84a5062073930d2199ac90238ca2c7a" name="af84a5062073930d2199ac90238ca2c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84a5062073930d2199ac90238ca2c7a">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::join </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>vector_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The provided vector of strings will be concatenated into a single string with the delimiter inserted between each string.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;std::string&gt; list = { <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>, <span class="stringliteral">&quot;blah&quot;</span> };</div>
<div class="line">std::string str = zakero::join(list, <span class="stringliteral">&quot;:&quot;</span>);</div>
<div class="line"><span class="comment">// str = &quot;foo:bar:blah&quot;;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_string</td><td>The strings to join</td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiter to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5978a7bbb78921ec03207e2497c140fa" name="a5978a7bbb78921ec03207e2497c140fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5978a7bbb78921ec03207e2497c140fa">&#9670;&#160;</a></span>mapKeys() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Key &gt; zakero::mapKeys </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, Value &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use this method to create a vector of all the keys in the provided <code>map</code>.</p>
<dl class="section note"><dt>Note</dt><dd>A copy of each key is made.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of keys. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2acc98326c47f46f52fa1bdb4c68bef" name="aa2acc98326c47f46f52fa1bdb4c68bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2acc98326c47f46f52fa1bdb4c68bef">&#9670;&#160;</a></span>mapKeys() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Key &gt; zakero::mapKeys </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; Key, Value &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use this method to create a vector of all the keys in the provided <code>map</code>.</p>
<dl class="section note"><dt>Note</dt><dd>A copy of each key is made.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of keys. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad33d5dbd1487acfa96d0febe96f1f901" name="ad33d5dbd1487acfa96d0febe96f1f901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33d5dbd1487acfa96d0febe96f1f901">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The <code>stream</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to use</td></tr>
    <tr><td class="paramname">error</td><td>The value in insert into the stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5c33f11940ead5652e83bb7c27acde1" name="ad5c33f11940ead5652e83bb7c27acde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c33f11940ead5652e83bb7c27acde1">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; zakero::split </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using this method will provide an easy way to split a string into smaller strings based on the specified <code>delimiter</code>. If two delimiters are next to eachother, an empty string will be used to represent that position.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::string str = <span class="stringliteral">&quot;foo:bar::blah&quot;</span>;</div>
<div class="line">std::vector&lt;std::string&gt; list = zakero::split(str, <span class="stringliteral">&quot;:&quot;</span>);</div>
<div class="line"><span class="comment">// list = [ &quot;foo&quot;, &quot;bar&quot;, &quot;&quot;, &quot;blah&quot; ]</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">A</td><td>vector of strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to split</td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiter to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18b16f691dda437260812968d8a79b3b" name="a18b16f691dda437260812968d8a79b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b16f691dda437260812968d8a79b3b">&#9670;&#160;</a></span>stob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zakero::stob </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Make the list of "true" string values convertible. <br  />
 (Compile-Time or Run-Time?)</dd></dl>
<p>This is intended to be a complement to the std::stod() and std::stoi() family of functions. However, the main restriction is this method only accepts certain string values to represent a boolean <code>true</code> value:</p><ul>
<li>"enable"</li>
<li>"enabled"</li>
<li>"true"</li>
<li>"t"</li>
<li>"yes"</li>
<li>"y"</li>
<li>"1" If the provided <code>str</code> is not one of the above strings, <code>false</code> will be returned.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The string comparison is <b>not</b> case-sensitive.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to a boolean value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0614fd99c6eb09a4c86ba1de0a214f35" name="a0614fd99c6eb09a4c86ba1de0a214f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0614fd99c6eb09a4c86ba1de0a214f35">&#9670;&#160;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::to_string </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a bool value in to either "true" or "false".</p>
<dl class="section return"><dt>Returns</dt><dd>A string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69db77331b1ac868a2f7400f1e119fc3" name="a69db77331b1ac868a2f7400f1e119fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69db77331b1ac868a2f7400f1e119fc3">&#9670;&#160;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The provided <code>error</code> will be converted to a string.</p>
<dl class="section return"><dt>Returns</dt><dd>A string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81d6f0c9fbcb578035b681dba751d87d" name="a81d6f0c9fbcb578035b681dba751d87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d6f0c9fbcb578035b681dba751d87d">&#9670;&#160;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::to_string </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>nanoseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The nanoseconds value will be converted into a string that contains "days", "hours", "minutes", "seconds", and (of course) "nanoseconds".</p>
<dl class="section return"><dt>Returns</dt><dd>A string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nanoseconds</td><td>The value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb2e6c7068a258d81fb0371f3d0e3063" name="adb2e6c7068a258d81fb0371f3d0e3063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2e6c7068a258d81fb0371f3d0e3063">&#9670;&#160;</a></span>tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::tolower </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The provided string, <code>str</code>, will be converted to lower-case using the default locale.</p>
<dl class="section return"><dt>Returns</dt><dd>The lower-case string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa939a096886f8989f7abb8b11c49ea81" name="aa939a096886f8989f7abb8b11c49ea81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa939a096886f8989f7abb8b11c49ea81">&#9670;&#160;</a></span>vectorContains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zakero::vectorContains </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A convience method to make searching a vector easier, like std::map::contains().</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;int&gt; v = { 0, 1, 2, 3 };</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(vectorContains(v, 1))</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// Found it</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The <code>value</code> was found. </td></tr>
    <tr><td class="paramname">false</td><td>The <code>value</code> was <b>not</b> found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The vector to search</td></tr>
    <tr><td class="paramname">value</td><td>The value to look for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ecded82e6c814381525228ff6cc78e1" name="a7ecded82e6c814381525228ff6cc78e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecded82e6c814381525228ff6cc78e1">&#9670;&#160;</a></span>vectorContains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIter , class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zakero::vectorContains </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A convenience method to make searching a vector easier. While this method does not save that many keystrokes, it does lead to more readable code.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;int&gt; v = { 0, 1, 2, 3 };</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(vectorContains(std::begin(v), std::end(v), 1)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// Found it</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compare with the &quot;long&quot; form, the</span></div>
<div class="line"><span class="comment">// value that is searched for gets lost</span></div>
<div class="line"><span class="comment">// very easily.</span></div>
<div class="line"><span class="keywordflow">if</span>(std::find(std::begin(v), std::end(v), 1) != std::end(v))</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// Found it</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The <code>value</code> was found. </td></tr>
    <tr><td class="paramname">false</td><td>The <code>value</code> was <b>not</b> found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start searching here</td></tr>
    <tr><td class="paramname">last</td><td>Stop searching here</td></tr>
    <tr><td class="paramname">value</td><td>The value to look for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64e48d2dfbdcb280dfb6324fad096f6d" name="a64e48d2dfbdcb280dfb6324fad096f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e48d2dfbdcb280dfb6324fad096f6d">&#9670;&#160;</a></span>vectorErase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto zakero::vectorErase </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A convenience method to make removing content from a vector easier. <br  />
 Uses the "Erase/Remove Idiom".</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;int&gt; v = { 0, 1, 2, 3 };</div>
<div class="line"> </div>
<div class="line">vectorErase(v, 2);</div>
<div class="line"><span class="comment">// v = { 0, 1, 3 };</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The <code>value</code> was found. </td></tr>
    <tr><td class="paramname">false</td><td>The <code>value</code> was <b>not</b> found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The vector to search</td></tr>
    <tr><td class="paramname">value</td><td>The value to look for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fbb9c0e79fdc0ee2a902264291aa4fe" name="a5fbb9c0e79fdc0ee2a902264291aa4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbb9c0e79fdc0ee2a902264291aa4fe">&#9670;&#160;</a></span>vectorErase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto zakero::vectorErase </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; Type &gt;::iterator&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A convenience method to make removing content from a vector easier. <br  />
 The order of the element in the <code>vector</code> are <b>NOT</b> preserved. The reason is to make the removal of the data at the <code>iter</code> location as fast as possible.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;int&gt; v = { 0, 1, 2, 3 };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> iter = std::next(std::begin(v));</div>
<div class="line"> </div>
<div class="line">vectorErase(v, iter);</div>
<div class="line"><span class="comment">// v = { 0, 3, 2 };</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The <code>value</code> was found. </td></tr>
    <tr><td class="paramname">false</td><td>The <code>value</code> was <b>not</b> found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The vector to search</td></tr>
    <tr><td class="paramname">iter</td><td>The iterator to erase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
