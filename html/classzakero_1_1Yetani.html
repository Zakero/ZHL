<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zakero&#39;s C++ Header Libraries: zakero::Yetani Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zakero&#39;s C++ Header Libraries
   </div>
   <div id="projectbrief">A collection of reusable C++ libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>zakero</b></li><li class="navelem"><a class="el" href="classzakero_1_1Yetani.html">Yetani</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classzakero_1_1Yetani-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">zakero::Yetani Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A wrapper class for Wayland.  
 <a href="classzakero_1_1Yetani.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structzakero_1_1Yetani_1_1CursorConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1CursorConfig">CursorConfig</a></td></tr>
<tr class="memdesc:structzakero_1_1Yetani_1_1CursorConfig"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cursor configuration.  <a href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1CursorConfig">More...</a><br /></td></tr>
<tr class="separator:structzakero_1_1Yetani_1_1CursorConfig"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structzakero_1_1Yetani_1_1Key"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Key">Key</a></td></tr>
<tr class="memdesc:structzakero_1_1Yetani_1_1Key"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key event information.  <a href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Key">More...</a><br /></td></tr>
<tr class="separator:structzakero_1_1Yetani_1_1Key"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structzakero_1_1Yetani_1_1KeyModifier"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">KeyModifier</a></td></tr>
<tr class="memdesc:structzakero_1_1Yetani_1_1KeyModifier"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection modifier flags.  <a href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">More...</a><br /></td></tr>
<tr class="separator:structzakero_1_1Yetani_1_1KeyModifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structzakero_1_1Yetani_1_1Output"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output">Output</a></td></tr>
<tr class="memdesc:structzakero_1_1Yetani_1_1Output"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a output device.  <a href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output">More...</a><br /></td></tr>
<tr class="separator:structzakero_1_1Yetani_1_1Output"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structzakero_1_1Yetani_1_1PointerAxis"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerAxis">PointerAxis</a></td></tr>
<tr class="memdesc:structzakero_1_1Yetani_1_1PointerAxis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about an Axis event.  <a href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerAxis">More...</a><br /></td></tr>
<tr class="separator:structzakero_1_1Yetani_1_1PointerAxis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structzakero_1_1Yetani_1_1PointerButton"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerButton">PointerButton</a></td></tr>
<tr class="memdesc:structzakero_1_1Yetani_1_1PointerButton"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a pointer button event.  <a href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerButton">More...</a><br /></td></tr>
<tr class="separator:structzakero_1_1Yetani_1_1PointerButton"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzakero_1_1Yetani_1_1PointMm.html">PointMm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A location that uses millimeters.  <a href="structzakero_1_1Yetani_1_1PointMm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzakero_1_1Yetani_1_1PointPercent.html">PointPercent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A location that uses percentages.  <a href="structzakero_1_1Yetani_1_1PointPercent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">PointPixel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A location that uses pixels.  <a href="structzakero_1_1Yetani_1_1PointPixel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">SizeMm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size measured in millimeters.  <a href="structzakero_1_1Yetani_1_1SizeMm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">SizePercent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size measured as a percentage of the <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> (Monitor) resolution.  <a href="structzakero_1_1Yetani_1_1SizePercent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">SizePixel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size measured in pixels.  <a href="structzakero_1_1Yetani_1_1SizePixel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Window</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Window.  <a href="classzakero_1_1Yetani_1_1Window.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a904a1d471bf7a7d3bd7c2b3c067d4eec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a904a1d471bf7a7d3bd7c2b3c067d4eec">KeyState</a> </td></tr>
<tr class="memdesc:a904a1d471bf7a7d3bd7c2b3c067d4eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keyboard key state  <a href="classzakero_1_1Yetani.html#a904a1d471bf7a7d3bd7c2b3c067d4eec">More...</a><br /></td></tr>
<tr class="separator:a904a1d471bf7a7d3bd7c2b3c067d4eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ba4ebcc1abb40b936d22821fe4daab"><td class="memItemLeft" align="right" valign="top"><a id="a58ba4ebcc1abb40b936d22821fe4daab"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a58ba4ebcc1abb40b936d22821fe4daab">PointerAxisSource</a> </td></tr>
<tr class="memdesc:a58ba4ebcc1abb40b936d22821fe4daab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where the axis information came from. <br /></td></tr>
<tr class="separator:a58ba4ebcc1abb40b936d22821fe4daab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42274f7b4896cb3a82707a7659fba5f2"><td class="memItemLeft" align="right" valign="top"><a id="a42274f7b4896cb3a82707a7659fba5f2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a42274f7b4896cb3a82707a7659fba5f2">PointerAxisType</a> </td></tr>
<tr class="memdesc:a42274f7b4896cb3a82707a7659fba5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The direction of the axis movement. <br /></td></tr>
<tr class="separator:a42274f7b4896cb3a82707a7659fba5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443f97670ca82036adb6684fcadef53b"><td class="memItemLeft" align="right" valign="top"><a id="a443f97670ca82036adb6684fcadef53b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a443f97670ca82036adb6684fcadef53b">PointerButtonState</a> </td></tr>
<tr class="memdesc:a443f97670ca82036adb6684fcadef53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mouse button state. <br /></td></tr>
<tr class="separator:a443f97670ca82036adb6684fcadef53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b7e32a83ba157559003600f73e6263"><td class="memItemLeft" align="right" valign="top"><a id="a88b7e32a83ba157559003600f73e6263"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a88b7e32a83ba157559003600f73e6263">WindowDecorations</a> </td></tr>
<tr class="memdesc:a88b7e32a83ba157559003600f73e6263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Who is responsible for rendering the decorations. <br /></td></tr>
<tr class="separator:a88b7e32a83ba157559003600f73e6263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2601eed0ec5db5e6117d26535a8e0e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ac2601eed0ec5db5e6117d26535a8e0e6">WindowMode</a> </td></tr>
<tr class="separator:ac2601eed0ec5db5e6117d26535a8e0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab9adae281d9541c70fc685069893a983"><td class="memItemLeft" align="right" valign="top">virtual ZAKERO_YETANI__ERROR_DATA&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ab9adae281d9541c70fc685069893a983">~Yetani</a> () noexcept</td></tr>
<tr class="memdesc:ab9adae281d9541c70fc685069893a983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classzakero_1_1Yetani.html#ab9adae281d9541c70fc685069893a983">More...</a><br /></td></tr>
<tr class="separator:ab9adae281d9541c70fc685069893a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d0d4630a1e65ae93e6cc20d5fee4f6"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a63d0d4630a1e65ae93e6cc20d5fee4f6">cursorCreate</a> (const std::string &amp;, const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1CursorConfig">Yetani::CursorConfig</a> &amp;) noexcept</td></tr>
<tr class="memdesc:a63d0d4630a1e65ae93e6cc20d5fee4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cursor.  <a href="classzakero_1_1Yetani.html#a63d0d4630a1e65ae93e6cc20d5fee4f6">More...</a><br /></td></tr>
<tr class="separator:a63d0d4630a1e65ae93e6cc20d5fee4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e02d816f6d3c52ffbeea1abc7d1c457"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a7e02d816f6d3c52ffbeea1abc7d1c457">cursorDestroy</a> (const std::string &amp;) noexcept</td></tr>
<tr class="memdesc:a7e02d816f6d3c52ffbeea1abc7d1c457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a cursor.  <a href="classzakero_1_1Yetani.html#a7e02d816f6d3c52ffbeea1abc7d1c457">More...</a><br /></td></tr>
<tr class="separator:a7e02d816f6d3c52ffbeea1abc7d1c457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cd01ea08eda690b256cf0665b5d892"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a27cd01ea08eda690b256cf0665b5d892">keyRepeatDelay</a> () const noexcept</td></tr>
<tr class="memdesc:a27cd01ea08eda690b256cf0665b5d892"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key repeat delay.  <a href="classzakero_1_1Yetani.html#a27cd01ea08eda690b256cf0665b5d892">More...</a><br /></td></tr>
<tr class="separator:a27cd01ea08eda690b256cf0665b5d892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715553d39084a9b336ba1dae6f71b9be"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a715553d39084a9b336ba1dae6f71b9be">keyRepeatRate</a> () const noexcept</td></tr>
<tr class="memdesc:a715553d39084a9b336ba1dae6f71b9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key repeat rate.  <a href="classzakero_1_1Yetani.html#a715553d39084a9b336ba1dae6f71b9be">More...</a><br /></td></tr>
<tr class="separator:a715553d39084a9b336ba1dae6f71b9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d11478a780d9b57e86638ee1b296b81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output">Yetani::Output</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a3d11478a780d9b57e86638ee1b296b81">output</a> (const Yetani::OutputId) const noexcept</td></tr>
<tr class="memdesc:a3d11478a780d9b57e86638ee1b296b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> information.  <a href="classzakero_1_1Yetani.html#a3d11478a780d9b57e86638ee1b296b81">More...</a><br /></td></tr>
<tr class="separator:a3d11478a780d9b57e86638ee1b296b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0adb15f54b21f19def68cea4be3b75a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structzakero_1_1Yetani_1_1PointMm.html">Yetani::PointMm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#af0adb15f54b21f19def68cea4be3b75a">outputConvertToMm</a> (const Yetani::OutputId, const <a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:af0adb15f54b21f19def68cea4be3b75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Pixel to Millimeter.  <a href="classzakero_1_1Yetani.html#af0adb15f54b21f19def68cea4be3b75a">More...</a><br /></td></tr>
<tr class="separator:af0adb15f54b21f19def68cea4be3b75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188bcaf0e6694e80876973f8abffd7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a188bcaf0e6694e80876973f8abffd7b7">outputConvertToMm</a> (const Yetani::OutputId, const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:a188bcaf0e6694e80876973f8abffd7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Pixel to Millimeter.  <a href="classzakero_1_1Yetani.html#a188bcaf0e6694e80876973f8abffd7b7">More...</a><br /></td></tr>
<tr class="separator:a188bcaf0e6694e80876973f8abffd7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b411cbfc021a3486b796bdb2a494e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structzakero_1_1Yetani_1_1PointPercent.html">Yetani::PointPercent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a39b411cbfc021a3486b796bdb2a494e9">outputConvertToPercent</a> (const Yetani::OutputId, const <a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:a39b411cbfc021a3486b796bdb2a494e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Pixel to a Percentage.  <a href="classzakero_1_1Yetani.html#a39b411cbfc021a3486b796bdb2a494e9">More...</a><br /></td></tr>
<tr class="separator:a39b411cbfc021a3486b796bdb2a494e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace580fc683773b95881248936fb450d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ace580fc683773b95881248936fb450d9">outputConvertToPercent</a> (const Yetani::OutputId, const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:ace580fc683773b95881248936fb450d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Pixel to a Percentage.  <a href="classzakero_1_1Yetani.html#ace580fc683773b95881248936fb450d9">More...</a><br /></td></tr>
<tr class="separator:ace580fc683773b95881248936fb450d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339bcf6d59d9fce37fe84ad6c0aafa43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a339bcf6d59d9fce37fe84ad6c0aafa43">outputConvertToPixel</a> (const Yetani::OutputId, const <a class="el" href="structzakero_1_1Yetani_1_1PointMm.html">Yetani::PointMm</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:a339bcf6d59d9fce37fe84ad6c0aafa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Millimeter to Pixel.  <a href="classzakero_1_1Yetani.html#a339bcf6d59d9fce37fe84ad6c0aafa43">More...</a><br /></td></tr>
<tr class="separator:a339bcf6d59d9fce37fe84ad6c0aafa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3097ba563e74ada5ea6a0a5fba95bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#aed3097ba563e74ada5ea6a0a5fba95bb">outputConvertToPixel</a> (const Yetani::OutputId, const <a class="el" href="structzakero_1_1Yetani_1_1PointPercent.html">Yetani::PointPercent</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:aed3097ba563e74ada5ea6a0a5fba95bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Percentage to Pixel.  <a href="classzakero_1_1Yetani.html#aed3097ba563e74ada5ea6a0a5fba95bb">More...</a><br /></td></tr>
<tr class="separator:aed3097ba563e74ada5ea6a0a5fba95bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c70746472ab4934f566a44862bcf1d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a2c70746472ab4934f566a44862bcf1d6">outputConvertToPixel</a> (const Yetani::OutputId, const <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:a2c70746472ab4934f566a44862bcf1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Millimeter to Pixel.  <a href="classzakero_1_1Yetani.html#a2c70746472ab4934f566a44862bcf1d6">More...</a><br /></td></tr>
<tr class="separator:a2c70746472ab4934f566a44862bcf1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3615f44aecf594b42d3b2666ed0f6735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a3615f44aecf594b42d3b2666ed0f6735">outputConvertToPixel</a> (const Yetani::OutputId, const <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:a3615f44aecf594b42d3b2666ed0f6735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Percentage to Pixel.  <a href="classzakero_1_1Yetani.html#a3615f44aecf594b42d3b2666ed0f6735">More...</a><br /></td></tr>
<tr class="separator:a3615f44aecf594b42d3b2666ed0f6735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327d74fb81899e02b0ba672cd6483d35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a327d74fb81899e02b0ba672cd6483d35">outputOnAdd</a> (Yetani::LambdaOutputId) noexcept</td></tr>
<tr class="memdesc:a327d74fb81899e02b0ba672cd6483d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification of adding an <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> device.  <a href="classzakero_1_1Yetani.html#a327d74fb81899e02b0ba672cd6483d35">More...</a><br /></td></tr>
<tr class="separator:a327d74fb81899e02b0ba672cd6483d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4316c6cd8ee78599fdfbf348342d9f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a4316c6cd8ee78599fdfbf348342d9f95">outputOnChange</a> (Yetani::LambdaOutputId) noexcept</td></tr>
<tr class="memdesc:a4316c6cd8ee78599fdfbf348342d9f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that an <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> device has changed.  <a href="classzakero_1_1Yetani.html#a4316c6cd8ee78599fdfbf348342d9f95">More...</a><br /></td></tr>
<tr class="separator:a4316c6cd8ee78599fdfbf348342d9f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567ad366591e5a067d5c54b503db9348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a567ad366591e5a067d5c54b503db9348">outputOnRemove</a> (Yetani::LambdaOutputId) noexcept</td></tr>
<tr class="memdesc:a567ad366591e5a067d5c54b503db9348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification of removing an <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> device.  <a href="classzakero_1_1Yetani.html#a567ad366591e5a067d5c54b503db9348">More...</a><br /></td></tr>
<tr class="separator:a567ad366591e5a067d5c54b503db9348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a442911a60e62ea5c163b3c3b5a894"><td class="memItemLeft" align="right" valign="top">Yetani::VectorOutputId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a21a442911a60e62ea5c163b3c3b5a894">outputVector</a> () const noexcept</td></tr>
<tr class="memdesc:a21a442911a60e62ea5c163b3c3b5a894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of the <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> Id's.  <a href="classzakero_1_1Yetani.html#a21a442911a60e62ea5c163b3c3b5a894">More...</a><br /></td></tr>
<tr class="separator:a21a442911a60e62ea5c163b3c3b5a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c51a51c7a126cc32dcf5c3a6c6bbb6b"><td class="memItemLeft" align="right" valign="top">const Yetani::VectorShmFormat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a7c51a51c7a126cc32dcf5c3a6c6bbb6b">shmFormatAvailable</a> () const noexcept</td></tr>
<tr class="memdesc:a7c51a51c7a126cc32dcf5c3a6c6bbb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the support color formats.  <a href="classzakero_1_1Yetani.html#a7c51a51c7a126cc32dcf5c3a6c6bbb6b">More...</a><br /></td></tr>
<tr class="separator:a7c51a51c7a126cc32dcf5c3a6c6bbb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40a22e06b3f05cbf3a83e88c3019acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ac40a22e06b3f05cbf3a83e88c3019acb">windowCreate</a> (const <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> &amp;, const wl_shm_format, std::error_code &amp;) noexcept</td></tr>
<tr class="memdesc:ac40a22e06b3f05cbf3a83e88c3019acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a window.  <a href="classzakero_1_1Yetani.html#ac40a22e06b3f05cbf3a83e88c3019acb">More...</a><br /></td></tr>
<tr class="separator:ac40a22e06b3f05cbf3a83e88c3019acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c0ff718af6c02ae63d2fcad158548a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ae5c0ff718af6c02ae63d2fcad158548a">windowCreate</a> (const <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> &amp;, const wl_shm_format=<a class="el" href="classzakero_1_1Yetani.html#a4f0707f559705cee3789766694a00821">SHM_FORMAT_DEFAULT</a>) noexcept</td></tr>
<tr class="memdesc:ae5c0ff718af6c02ae63d2fcad158548a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a window.  <a href="classzakero_1_1Yetani.html#ae5c0ff718af6c02ae63d2fcad158548a">More...</a><br /></td></tr>
<tr class="separator:ae5c0ff718af6c02ae63d2fcad158548a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419c666f48108c08bd666d1dbf2a534b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a419c666f48108c08bd666d1dbf2a534b">windowCreate</a> (const <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> &amp;, std::error_code &amp;) noexcept</td></tr>
<tr class="memdesc:a419c666f48108c08bd666d1dbf2a534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a window.  <a href="classzakero_1_1Yetani.html#a419c666f48108c08bd666d1dbf2a534b">More...</a><br /></td></tr>
<tr class="separator:a419c666f48108c08bd666d1dbf2a534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f63e54c86fc840e2e8e136cceed983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a03f63e54c86fc840e2e8e136cceed983">windowCreate</a> (const <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> &amp;, const wl_shm_format, std::error_code &amp;) noexcept</td></tr>
<tr class="memdesc:a03f63e54c86fc840e2e8e136cceed983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a window.  <a href="classzakero_1_1Yetani.html#a03f63e54c86fc840e2e8e136cceed983">More...</a><br /></td></tr>
<tr class="separator:a03f63e54c86fc840e2e8e136cceed983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eb5293e84859f8b2ab3e266a5f0ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ab5eb5293e84859f8b2ab3e266a5f0ee9">windowCreate</a> (const <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> &amp;, const wl_shm_format=<a class="el" href="classzakero_1_1Yetani.html#a4f0707f559705cee3789766694a00821">SHM_FORMAT_DEFAULT</a>) noexcept</td></tr>
<tr class="memdesc:ab5eb5293e84859f8b2ab3e266a5f0ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a window.  <a href="classzakero_1_1Yetani.html#ab5eb5293e84859f8b2ab3e266a5f0ee9">More...</a><br /></td></tr>
<tr class="separator:ab5eb5293e84859f8b2ab3e266a5f0ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a41c39af298cad3c8e2d3e71a6be21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a42a41c39af298cad3c8e2d3e71a6be21">windowCreate</a> (const <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> &amp;, std::error_code &amp;) noexcept</td></tr>
<tr class="memdesc:a42a41c39af298cad3c8e2d3e71a6be21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a window.  <a href="classzakero_1_1Yetani.html#a42a41c39af298cad3c8e2d3e71a6be21">More...</a><br /></td></tr>
<tr class="separator:a42a41c39af298cad3c8e2d3e71a6be21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5b59695086f17d14da37f734ec45f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#aaa5b59695086f17d14da37f734ec45f5">windowCreate</a> (const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;, const wl_shm_format, std::error_code &amp;) noexcept</td></tr>
<tr class="memdesc:aaa5b59695086f17d14da37f734ec45f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a window.  <a href="classzakero_1_1Yetani.html#aaa5b59695086f17d14da37f734ec45f5">More...</a><br /></td></tr>
<tr class="separator:aaa5b59695086f17d14da37f734ec45f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedce34d1ba2bc817cc509c54101458c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#aedce34d1ba2bc817cc509c54101458c2">windowCreate</a> (const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;, const wl_shm_format=<a class="el" href="classzakero_1_1Yetani.html#a4f0707f559705cee3789766694a00821">SHM_FORMAT_DEFAULT</a>) noexcept</td></tr>
<tr class="memdesc:aedce34d1ba2bc817cc509c54101458c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a window.  <a href="classzakero_1_1Yetani.html#aedce34d1ba2bc817cc509c54101458c2">More...</a><br /></td></tr>
<tr class="separator:aedce34d1ba2bc817cc509c54101458c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77d5527582bb006db4e2d2002aa841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#acd77d5527582bb006db4e2d2002aa841">windowCreate</a> (const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;, std::error_code &amp;) noexcept</td></tr>
<tr class="memdesc:acd77d5527582bb006db4e2d2002aa841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a window.  <a href="classzakero_1_1Yetani.html#acd77d5527582bb006db4e2d2002aa841">More...</a><br /></td></tr>
<tr class="separator:acd77d5527582bb006db4e2d2002aa841"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a61707e5ddf512891501b1d082a837d25"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classzakero_1_1Yetani.html">Yetani</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a61707e5ddf512891501b1d082a837d25">connect</a> () noexcept</td></tr>
<tr class="memdesc:a61707e5ddf512891501b1d082a837d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a connection with the Wayland Compositor.  <a href="classzakero_1_1Yetani.html#a61707e5ddf512891501b1d082a837d25">More...</a><br /></td></tr>
<tr class="separator:a61707e5ddf512891501b1d082a837d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102ed2ded260482cd3446d5c747239fb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classzakero_1_1Yetani.html">Yetani</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a102ed2ded260482cd3446d5c747239fb">connect</a> (const std::string &amp;) noexcept</td></tr>
<tr class="memdesc:a102ed2ded260482cd3446d5c747239fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a connection with the Wayland Compositor.  <a href="classzakero_1_1Yetani.html#a102ed2ded260482cd3446d5c747239fb">More...</a><br /></td></tr>
<tr class="separator:a102ed2ded260482cd3446d5c747239fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ac4519a0eb85e9569a83ce7842d67a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classzakero_1_1Yetani.html">Yetani</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a02ac4519a0eb85e9569a83ce7842d67a">connect</a> (const std::string &amp;, std::error_code &amp;) noexcept</td></tr>
<tr class="memdesc:a02ac4519a0eb85e9569a83ce7842d67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a connection with the Wayland Compositor.  <a href="classzakero_1_1Yetani.html#a02ac4519a0eb85e9569a83ce7842d67a">More...</a><br /></td></tr>
<tr class="separator:a02ac4519a0eb85e9569a83ce7842d67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d38a2413361c8970b4c91998bb51f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classzakero_1_1Yetani.html">Yetani</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ad4d38a2413361c8970b4c91998bb51f1">connect</a> (std::error_code &amp;) noexcept</td></tr>
<tr class="memdesc:ad4d38a2413361c8970b4c91998bb51f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a connection with the Wayland Compositor.  <a href="classzakero_1_1Yetani.html#ad4d38a2413361c8970b4c91998bb51f1">More...</a><br /></td></tr>
<tr class="separator:ad4d38a2413361c8970b4c91998bb51f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebe046061081cffa084ef3afae92d92"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a0ebe046061081cffa084ef3afae92d92">outputSubpixelName</a> (int32_t) noexcept</td></tr>
<tr class="memdesc:a0ebe046061081cffa084ef3afae92d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a human readable string.  <a href="classzakero_1_1Yetani.html#a0ebe046061081cffa084ef3afae92d92">More...</a><br /></td></tr>
<tr class="separator:a0ebe046061081cffa084ef3afae92d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aad71992f986b026a730a1dc064222e"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a0aad71992f986b026a730a1dc064222e">outputTransformName</a> (int32_t) noexcept</td></tr>
<tr class="memdesc:a0aad71992f986b026a730a1dc064222e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a human readable string.  <a href="classzakero_1_1Yetani.html#a0aad71992f986b026a730a1dc064222e">More...</a><br /></td></tr>
<tr class="separator:a0aad71992f986b026a730a1dc064222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5431d29ccb5f6c8b248ca74e209b5cc"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ad5431d29ccb5f6c8b248ca74e209b5cc">shmFormatBytesPerPixel</a> (const wl_shm_format) noexcept</td></tr>
<tr class="memdesc:ad5431d29ccb5f6c8b248ca74e209b5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine bytes-per-pixel.  <a href="classzakero_1_1Yetani.html#ad5431d29ccb5f6c8b248ca74e209b5cc">More...</a><br /></td></tr>
<tr class="separator:ad5431d29ccb5f6c8b248ca74e209b5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bcc5ee2e3eb29b9e5690245f8f9741"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#af7bcc5ee2e3eb29b9e5690245f8f9741">shmFormatDescription</a> (const wl_shm_format) noexcept</td></tr>
<tr class="memdesc:af7bcc5ee2e3eb29b9e5690245f8f9741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a description of the format.  <a href="classzakero_1_1Yetani.html#af7bcc5ee2e3eb29b9e5690245f8f9741">More...</a><br /></td></tr>
<tr class="separator:af7bcc5ee2e3eb29b9e5690245f8f9741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21773e27cac9c0d7c09bab553f7ec7d9"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a21773e27cac9c0d7c09bab553f7ec7d9">shmFormatName</a> (const wl_shm_format) noexcept</td></tr>
<tr class="memdesc:a21773e27cac9c0d7c09bab553f7ec7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the format.  <a href="classzakero_1_1Yetani.html#a21773e27cac9c0d7c09bab553f7ec7d9">More...</a><br /></td></tr>
<tr class="separator:a21773e27cac9c0d7c09bab553f7ec7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2e098c5d8d812d5e2f719eb493b05abb"><td class="memItemLeft" align="right" valign="top"><a id="a2e098c5d8d812d5e2f719eb493b05abb"></a>
static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a2e098c5d8d812d5e2f719eb493b05abb">KeyModifier_Alt</a></td></tr>
<tr class="memdesc:a2e098c5d8d812d5e2f719eb493b05abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Modifier flag. <br /></td></tr>
<tr class="separator:a2e098c5d8d812d5e2f719eb493b05abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521a4cad6cfe5ee277d5c1969843d06a"><td class="memItemLeft" align="right" valign="top"><a id="a521a4cad6cfe5ee277d5c1969843d06a"></a>
static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a521a4cad6cfe5ee277d5c1969843d06a">KeyModifier_CapsLock</a></td></tr>
<tr class="memdesc:a521a4cad6cfe5ee277d5c1969843d06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Modifier flag. <br /></td></tr>
<tr class="separator:a521a4cad6cfe5ee277d5c1969843d06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cbf15eef43a53073d45f37818a25b0"><td class="memItemLeft" align="right" valign="top"><a id="ad3cbf15eef43a53073d45f37818a25b0"></a>
static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ad3cbf15eef43a53073d45f37818a25b0">KeyModifier_Control</a></td></tr>
<tr class="memdesc:ad3cbf15eef43a53073d45f37818a25b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Modifier flag. <br /></td></tr>
<tr class="separator:ad3cbf15eef43a53073d45f37818a25b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371f0af237d1d78292451675519b6d1b"><td class="memItemLeft" align="right" valign="top"><a id="a371f0af237d1d78292451675519b6d1b"></a>
static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a371f0af237d1d78292451675519b6d1b">KeyModifier_Meta</a></td></tr>
<tr class="memdesc:a371f0af237d1d78292451675519b6d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Modifier flag. <br /></td></tr>
<tr class="separator:a371f0af237d1d78292451675519b6d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae183b0cdf244d4a591166de37356bafd"><td class="memItemLeft" align="right" valign="top"><a id="ae183b0cdf244d4a591166de37356bafd"></a>
static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ae183b0cdf244d4a591166de37356bafd">KeyModifier_Shift</a></td></tr>
<tr class="memdesc:ae183b0cdf244d4a591166de37356bafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Modifier flag. <br /></td></tr>
<tr class="separator:ae183b0cdf244d4a591166de37356bafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0707f559705cee3789766694a00821"><td class="memItemLeft" align="right" valign="top"><a id="a4f0707f559705cee3789766694a00821"></a>
static constexpr wl_shm_format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a4f0707f559705cee3789766694a00821">SHM_FORMAT_DEFAULT</a></td></tr>
<tr class="memdesc:a4f0707f559705cee3789766694a00821"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default pixel format. <br /></td></tr>
<tr class="separator:a4f0707f559705cee3789766694a00821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Lambdas</h2></td></tr>
<tr class="memitem:a67cc71aa05be2bee03bf212f1d4f8116"><td class="memItemLeft" align="right" valign="top"><a id="a67cc71aa05be2bee03bf212f1d4f8116"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a67cc71aa05be2bee03bf212f1d4f8116">Lambda</a> = std::function&lt; void()&gt;</td></tr>
<tr class="memdesc:a67cc71aa05be2bee03bf212f1d4f8116"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has no parameters. <br /></td></tr>
<tr class="separator:a67cc71aa05be2bee03bf212f1d4f8116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6e3531217544627c8d21516f4a83a2"><td class="memItemLeft" align="right" valign="top"><a id="a0e6e3531217544627c8d21516f4a83a2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a0e6e3531217544627c8d21516f4a83a2">LambdaKey</a> = std::function&lt; void(const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Key">Yetani::Key</a> &amp;, const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">Yetani::KeyModifier</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a0e6e3531217544627c8d21516f4a83a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has parameters: <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Key" title="Key event information.">Key</a> and <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier" title="A collection modifier flags.">KeyModifier</a>. <br /></td></tr>
<tr class="separator:a0e6e3531217544627c8d21516f4a83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59363d3e9580853a4f54cec861e34530"><td class="memItemLeft" align="right" valign="top"><a id="a59363d3e9580853a4f54cec861e34530"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a59363d3e9580853a4f54cec861e34530">LambdaAxis</a> = std::function&lt; void(const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerAxis">Yetani::PointerAxis</a> &amp;, const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">Yetani::KeyModifier</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a59363d3e9580853a4f54cec861e34530"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has parameters: <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerAxis" title="Information about an Axis event.">PointerAxis</a> and <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier" title="A collection modifier flags.">KeyModifier</a>. <br /></td></tr>
<tr class="separator:a59363d3e9580853a4f54cec861e34530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfef6bbfa6b6291a6ef1216b6aa90f7e"><td class="memItemLeft" align="right" valign="top"><a id="abfef6bbfa6b6291a6ef1216b6aa90f7e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#abfef6bbfa6b6291a6ef1216b6aa90f7e">LambdaButtonMm</a> = std::function&lt; void(const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerButton">Yetani::PointerButton</a> &amp;, const <a class="el" href="structzakero_1_1Yetani_1_1PointMm.html">Yetani::PointMm</a> &amp;, const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">Yetani::KeyModifier</a> &amp;)&gt;</td></tr>
<tr class="memdesc:abfef6bbfa6b6291a6ef1216b6aa90f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has parameters: <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerButton" title="Information about a pointer button event.">PointerButton</a>, <a class="el" href="structzakero_1_1Yetani_1_1PointMm.html" title="A location that uses millimeters.">PointMm</a> and <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier" title="A collection modifier flags.">KeyModifier</a>. <br /></td></tr>
<tr class="separator:abfef6bbfa6b6291a6ef1216b6aa90f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc7cae0bace14caf6892a14f752c6d3"><td class="memItemLeft" align="right" valign="top"><a id="a1fc7cae0bace14caf6892a14f752c6d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a1fc7cae0bace14caf6892a14f752c6d3">LambdaButtonPercent</a> = std::function&lt; void(const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerButton">Yetani::PointerButton</a> &amp;, const <a class="el" href="structzakero_1_1Yetani_1_1PointPercent.html">Yetani::PointPercent</a> &amp;, const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">Yetani::KeyModifier</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a1fc7cae0bace14caf6892a14f752c6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has parameters: <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerButton" title="Information about a pointer button event.">PointerButton</a>, <a class="el" href="structzakero_1_1Yetani_1_1PointPercent.html" title="A location that uses percentages.">PointPercent</a> and <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier" title="A collection modifier flags.">KeyModifier</a>. <br /></td></tr>
<tr class="separator:a1fc7cae0bace14caf6892a14f752c6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2ee3042c5a75a94cd04b2860177a42"><td class="memItemLeft" align="right" valign="top"><a id="a4e2ee3042c5a75a94cd04b2860177a42"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a4e2ee3042c5a75a94cd04b2860177a42">LambdaButtonPixel</a> = std::function&lt; void(const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerButton">Yetani::PointerButton</a> &amp;, const <a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a> &amp;, const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">Yetani::KeyModifier</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a4e2ee3042c5a75a94cd04b2860177a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has parameters: <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1PointerButton" title="Information about a pointer button event.">PointerButton</a>, <a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html" title="A location that uses pixels.">PointPixel</a> and <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier" title="A collection modifier flags.">KeyModifier</a>. <br /></td></tr>
<tr class="separator:a4e2ee3042c5a75a94cd04b2860177a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9f2b18f9c25b1ef6c9ca337d466153"><td class="memItemLeft" align="right" valign="top"><a id="a5b9f2b18f9c25b1ef6c9ca337d466153"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a5b9f2b18f9c25b1ef6c9ca337d466153">LambdaPointMm</a> = std::function&lt; void(const <a class="el" href="structzakero_1_1Yetani_1_1PointMm.html">Yetani::PointMm</a> &amp;, const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">Yetani::KeyModifier</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a5b9f2b18f9c25b1ef6c9ca337d466153"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has parameters: <a class="el" href="structzakero_1_1Yetani_1_1PointMm.html" title="A location that uses millimeters.">PointMm</a> and <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier" title="A collection modifier flags.">KeyModifier</a>. <br /></td></tr>
<tr class="separator:a5b9f2b18f9c25b1ef6c9ca337d466153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a277f2b89c44d4be7f3729be06bab5"><td class="memItemLeft" align="right" valign="top"><a id="a65a277f2b89c44d4be7f3729be06bab5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a65a277f2b89c44d4be7f3729be06bab5">LambdaPointPercent</a> = std::function&lt; void(const <a class="el" href="structzakero_1_1Yetani_1_1PointPercent.html">Yetani::PointPercent</a> &amp;, const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">Yetani::KeyModifier</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a65a277f2b89c44d4be7f3729be06bab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has parameters: <a class="el" href="structzakero_1_1Yetani_1_1PointPercent.html" title="A location that uses percentages.">PointPercent</a> and <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier" title="A collection modifier flags.">KeyModifier</a>. <br /></td></tr>
<tr class="separator:a65a277f2b89c44d4be7f3729be06bab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45f4b866ac6f9b067d8cec3e168b9dc"><td class="memItemLeft" align="right" valign="top"><a id="ab45f4b866ac6f9b067d8cec3e168b9dc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ab45f4b866ac6f9b067d8cec3e168b9dc">LambdaPointPixel</a> = std::function&lt; void(const <a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a> &amp;, const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier">Yetani::KeyModifier</a> &amp;)&gt;</td></tr>
<tr class="memdesc:ab45f4b866ac6f9b067d8cec3e168b9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has parameters: <a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html" title="A location that uses pixels.">PointPixel</a> and <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1KeyModifier" title="A collection modifier flags.">KeyModifier</a>. <br /></td></tr>
<tr class="separator:ab45f4b866ac6f9b067d8cec3e168b9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f4ec622c8e50bd0c2506de5b7f57a8"><td class="memItemLeft" align="right" valign="top"><a id="ab5f4ec622c8e50bd0c2506de5b7f57a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#ab5f4ec622c8e50bd0c2506de5b7f57a8">LambdaBool</a> = std::function&lt; void(bool)&gt;</td></tr>
<tr class="memdesc:ab5f4ec622c8e50bd0c2506de5b7f57a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has a parameter: bool. <br /></td></tr>
<tr class="separator:ab5f4ec622c8e50bd0c2506de5b7f57a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf67bc8fa68c711c3e404d2c6105eca4"><td class="memItemLeft" align="right" valign="top"><a id="acf67bc8fa68c711c3e404d2c6105eca4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#acf67bc8fa68c711c3e404d2c6105eca4">LambdaWindowDecorations</a> = std::function&lt; void(<a class="el" href="classzakero_1_1Yetani.html#a88b7e32a83ba157559003600f73e6263">Yetani::WindowDecorations</a>)&gt;</td></tr>
<tr class="memdesc:acf67bc8fa68c711c3e404d2c6105eca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has a parameter: WindowDecorations. <br /></td></tr>
<tr class="separator:acf67bc8fa68c711c3e404d2c6105eca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b772ea8868e94b8b4570d06e4643e2"><td class="memItemLeft" align="right" valign="top"><a id="a48b772ea8868e94b8b4570d06e4643e2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a48b772ea8868e94b8b4570d06e4643e2">LambdaWindowMode</a> = std::function&lt; void(<a class="el" href="classzakero_1_1Yetani.html#ac2601eed0ec5db5e6117d26535a8e0e6">Yetani::WindowMode</a>)&gt;</td></tr>
<tr class="memdesc:a48b772ea8868e94b8b4570d06e4643e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has a parameter: WindowMode. <br /></td></tr>
<tr class="separator:a48b772ea8868e94b8b4570d06e4643e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fa0a747c629a4c3603a127e3329237"><td class="memItemLeft" align="right" valign="top"><a id="a77fa0a747c629a4c3603a127e3329237"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a77fa0a747c629a4c3603a127e3329237">LambdaSizeMm</a> = std::function&lt; void(const <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a77fa0a747c629a4c3603a127e3329237"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has a parameter: <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html" title="Size measured in millimeters.">SizeMm</a>. <br /></td></tr>
<tr class="separator:a77fa0a747c629a4c3603a127e3329237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84885b4888c103cb7998f0b57920a874"><td class="memItemLeft" align="right" valign="top"><a id="a84885b4888c103cb7998f0b57920a874"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#a84885b4888c103cb7998f0b57920a874">LambdaSizePercent</a> = std::function&lt; void(const <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a84885b4888c103cb7998f0b57920a874"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has a parameter: <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html" title="Size measured as a percentage of the Output (Monitor) resolution.">SizePercent</a>. <br /></td></tr>
<tr class="separator:a84885b4888c103cb7998f0b57920a874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb34b3db0fd69ad642ab746eb4379f6c"><td class="memItemLeft" align="right" valign="top"><a id="acb34b3db0fd69ad642ab746eb4379f6c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1Yetani.html#acb34b3db0fd69ad642ab746eb4379f6c">LambdaSizePixel</a> = std::function&lt; void(const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;)&gt;</td></tr>
<tr class="memdesc:acb34b3db0fd69ad642ab746eb4379f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Lambda that has a parameter: <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html" title="Size measured in pixels.">SizePixel</a>. <br /></td></tr>
<tr class="separator:acb34b3db0fd69ad642ab746eb4379f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Refer to <a class="el" href="Zakero__Yetani_8h.html" title="Zakero Yetani.">Zakero_Yetani.h</a> to learn how to include this library.</p>
<p>The intent of this class is to make creating programs that interface directly with Wayland easier. While there are toolkits out there that do this (GTK, Qt, SDL, etc.), they also come with a lot of overhead. This class will abstract much of Wayland and provide a simple event driven interface.</p>
<p>As soon as a connection to the Wayland server has been established, a thread will be created to move all the communications to the background. This means that there is no "main loop" in the <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> object to hook into. The benefit to this is that <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> contents/graphics will not block event handling.</p>
<p>Refer to <a class="el" href="Zakero__Yetani_8h.html#zakero_yetani_how_to_use_it">How To Use It?</a> for a simple example.</p>
<dl class="section user"><dt>Window</dt><dd><p class="startdd">Using <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> to connect to a Wayland Compositor is just the first step. The next step is to create a <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> that can display <em>something</em>. This is done using one of the windowCreate() methods. There are 3 sets of methods:</p><ul>
<li>Millimeters<ul>
<li><a class="el" href="classzakero_1_1Yetani.html#a419c666f48108c08bd666d1dbf2a534b" title="Create a window.">windowCreate(const Yetani::SizeMm&amp;, std::error_code&amp;)</a></li>
<li><a class="el" href="classzakero_1_1Yetani.html#ae5c0ff718af6c02ae63d2fcad158548a" title="Create a window.">windowCreate(const Yetani::SizeMm&amp;, const wl_shm_format)</a></li>
<li><a class="el" href="classzakero_1_1Yetani.html#ac40a22e06b3f05cbf3a83e88c3019acb" title="Create a window.">windowCreate(const Yetani::SizeMm&amp;, const wl_shm_format, std::error_code&amp;)</a></li>
</ul>
</li>
<li>Percent<ul>
<li><a class="el" href="classzakero_1_1Yetani.html#a42a41c39af298cad3c8e2d3e71a6be21" title="Create a window.">windowCreate(const Yetani::SizePercent&amp;, std::error_code&amp;)</a></li>
<li><a class="el" href="classzakero_1_1Yetani.html#ab5eb5293e84859f8b2ab3e266a5f0ee9" title="Create a window.">windowCreate(const Yetani::SizePercent&amp;, const wl_shm_format)</a></li>
<li><a class="el" href="classzakero_1_1Yetani.html#a03f63e54c86fc840e2e8e136cceed983" title="Create a window.">windowCreate(const Yetani::SizePercent&amp;, const wl_shm_format, std::error_code&amp;)</a></li>
</ul>
</li>
<li>Pixels<ul>
<li><a class="el" href="classzakero_1_1Yetani.html#acd77d5527582bb006db4e2d2002aa841" title="Create a window.">windowCreate(const Yetani::SizePixel&amp;, std::error_code&amp;)</a></li>
<li><a class="el" href="classzakero_1_1Yetani.html#aedce34d1ba2bc817cc509c54101458c2" title="Create a window.">windowCreate(const Yetani::SizePixel&amp;, const wl_shm_format)</a></li>
<li><a class="el" href="classzakero_1_1Yetani.html#aaa5b59695086f17d14da37f734ec45f5" title="Create a window.">windowCreate(const Yetani::SizePixel&amp;, const wl_shm_format, std::error_code&amp;)</a></li>
</ul>
</li>
</ul>
<p class="interdd">Why three? The traditional pixels for size has many problems in today's display technology. A resolution of 1024x768 may sound consistent in that you know exactly how many pixels will be used on every display. However, 1024x768 may be OK on some displays, it may be too small on 4k laptop screens. And what about the 8k displays?</p>
<p class="interdd">The easy answer is to find the maximum resolution and use all of it, or just half for a windowed app. Instead of doing that work, why not just use percentages like 1.00x1.00 or 0.50x0.50 that will work on all display resolutions? That is why <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> has the <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html" title="Size measured as a percentage of the Output (Monitor) resolution.">SizePercent</a> object.</p>
<p class="interdd">What about millimeters? Using millimeters gives the developer more confidence that size of an area will be physically consistent across devices. To illustrate this consider defining a 300x150 button. This button may be easily clickable on most monitors but may be too small on a 4k display. Defining a button to be 20mm x 10mm, it will be the same physical size on all monitors.</p>
<p class="enddd">What's wrong with <a href="https://en.wikipedia.org/wiki/Dots_per_inch">DPI</a>? DPI has become a mess in the computer world and is resolution, not a size. </p>
</dd></dl>
<dl class="section user"><dt>Thread (not) Safe</dt><dd><p class="startdd">The main Wayland event loop runs in a dedicated thread. Because of this, there are race-conditions where execution uses the same data. The most likely thread conflict is the resizing of a surface:</p><ul>
<li>User Thread: Calling one of the window's "size" methods</li>
<li>Wayland Thread: Maximizing/Fullscreen/resizing the window</li>
</ul>
<p>While the above is mostly protected via mutexs' there is still a chance.</p>
<p class="interdd">There are other potential problems such as the User Thread deleting a window while the Wayland Thread is resizing the same window. To resolve this issue will require a complete evaluation of data and thread activities.</p>
<p class="enddd">Or take the easy way out and rewrite <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> to be single-threaded... </p>
</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>XDGOutput Support </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Client-Side Border </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Mouse-Look Support </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Touch Input Support </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Clipboard Support </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>cursorAliasAdd() (maybe) </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>cursorAliasRemove() (maybe) </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>cursorAvailableNames() (maybe) </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>cursorXDGLoad() (maybe) </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>Use <a class="el" href="Zakero__Base_8h.html#ac79e34323a85453ec650c1685790fb86" title="Delete memory.">ZAKERO_DELETE()</a> where it makes sense</dd></dl>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structzakero_1_1Yetani_1_1CursorConfig" id="structzakero_1_1Yetani_1_1CursorConfig"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structzakero_1_1Yetani_1_1CursorConfig">&#9670;&nbsp;</a></span>zakero::Yetani::CursorConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct zakero::Yetani::CursorConfig</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a824c2efa9c835cf0fb268f9b79a376ba"></a>wl_shm_format</td>
<td class="fieldname">
format</td>
<td class="fielddoc">
The pixel format. </td></tr>
<tr><td class="fieldtype">
<a id="a6200a0bb358ab2adfb0f02709d4a6769"></a>int32_t</td>
<td class="fieldname">
hotspot_x</td>
<td class="fielddoc">
The X location of the hotspot. </td></tr>
<tr><td class="fieldtype">
<a id="a7b3e3b9c9b56db6c521df68bfc6933ec"></a>int32_t</td>
<td class="fieldname">
hotspot_y</td>
<td class="fielddoc">
The Y location of the hotspot. </td></tr>
<tr><td class="fieldtype">
<a id="a1ee8e27c543d504820f764005aa579e0"></a>const vector&lt; void * &gt; &amp;</td>
<td class="fieldname">
image_data</td>
<td class="fielddoc">
A collection of image data. </td></tr>
<tr><td class="fieldtype">
<a id="aa1ac798b2d51f3875328f2524d017c40"></a><a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">SizePixel</a></td>
<td class="fieldname">
size</td>
<td class="fielddoc">
The size of the cursor. </td></tr>
<tr><td class="fieldtype">
<a id="a457a9bf3942ed18e9c96ee061f173c40"></a>milliseconds</td>
<td class="fieldname">
time_per_frame</td>
<td class="fielddoc">
How long to display each frame of animation. </td></tr>
</table>

</div>
</div>
<a name="structzakero_1_1Yetani_1_1Key" id="structzakero_1_1Yetani_1_1Key"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structzakero_1_1Yetani_1_1Key">&#9670;&nbsp;</a></span>zakero::Yetani::Key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct zakero::Yetani::Key</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Time is based on the "steady clock" and not system time. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a028002b078cf4fd24ab0439388132ee1"></a>uint32_t</td>
<td class="fieldname">
code</td>
<td class="fielddoc">
The key code of the event. </td></tr>
<tr><td class="fieldtype">
<a id="ac655a759e609567edf4dfc0d13bb484d"></a><a class="el" href="classzakero_1_1Yetani.html#a904a1d471bf7a7d3bd7c2b3c067d4eec">KeyState</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
The state of the key. </td></tr>
<tr><td class="fieldtype">
<a id="a46901aec077689373da88229e8b0141c"></a>uint32_t</td>
<td class="fieldname">
time</td>
<td class="fielddoc">
When the key event happened. </td></tr>
</table>

</div>
</div>
<a name="structzakero_1_1Yetani_1_1KeyModifier" id="structzakero_1_1Yetani_1_1KeyModifier"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structzakero_1_1Yetani_1_1KeyModifier">&#9670;&nbsp;</a></span>zakero::Yetani::KeyModifier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct zakero::Yetani::KeyModifier</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The meaning of the modifiers are:</p><ul>
<li><b>pressed</b><br  />
 This is the easiest to understand type of modifier. A modifier such as "Control" is pressed.</li>
<li><b>locked</b><br  />
 The best example of a "locked" modifier is the "Caps Lock" key.</li>
<li><b>latched</b><br  />
 This modifer can occur with "Sticky Keys". </li>
</ul>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aa886e811f5d7ea12dac0b5964cbc160f"></a>uint32_t</td>
<td class="fieldname">
group</td>
<td class="fielddoc">
The keyboard layout. </td></tr>
<tr><td class="fieldtype">
<a id="a60ece3df5dc339991985f40627313c68"></a>uint32_t</td>
<td class="fieldname">
latched</td>
<td class="fielddoc">
A collection of latched modifiers. </td></tr>
<tr><td class="fieldtype">
<a id="afc519cc4f84bc2237cc7615a14f09321"></a>uint32_t</td>
<td class="fieldname">
locked</td>
<td class="fielddoc">
A collection of locked modifiers. </td></tr>
<tr><td class="fieldtype">
<a id="a2fd1a39dff9c0f07d628cca5bca27652"></a>uint32_t</td>
<td class="fieldname">
pressed</td>
<td class="fielddoc">
A collection of pressed modifiers. </td></tr>
</table>

</div>
</div>
<a name="structzakero_1_1Yetani_1_1Output" id="structzakero_1_1Yetani_1_1Output"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structzakero_1_1Yetani_1_1Output">&#9670;&nbsp;</a></span>zakero::Yetani::Output</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct zakero::Yetani::Output</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>All the Wayland information about an output device in a single structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a4ecfe61026e0e3788c6093a2fabee0ba"></a>uint32_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
wl_output_mode bitfield properties. </td></tr>
<tr><td class="fieldtype">
<a id="a26b4ae0f485e823355e92796b1d1672e"></a>int32_t</td>
<td class="fieldname">
height</td>
<td class="fielddoc">
The height of the device in hardware units. </td></tr>
<tr><td class="fieldtype">
<a id="a09e8aa20af5b41ab3817765cfe9fc416"></a>string</td>
<td class="fieldname">
make</td>
<td class="fielddoc">
Description of the manufacturer. </td></tr>
<tr><td class="fieldtype">
<a id="a7abc178b81fd2a2be1f0343cb1efcd80"></a>string</td>
<td class="fieldname">
model</td>
<td class="fielddoc">
Description of the model. </td></tr>
<tr><td class="fieldtype">
<a id="a68bca5126576bbad530ac3a1867fa8e2"></a>uint32_t</td>
<td class="fieldname">
physical_height_mm</td>
<td class="fielddoc">
The height of the device in millimeters. </td></tr>
<tr><td class="fieldtype">
<a id="a6c146e3f303ac1087bbb3ec25ee2e90b"></a>uint32_t</td>
<td class="fieldname">
physical_width_mm</td>
<td class="fielddoc">
The width of the device in millimeters. </td></tr>
<tr><td class="fieldtype">
<a id="a103e3a5da334fd4f6213be9910e610b8"></a>float</td>
<td class="fieldname">
pixels_per_mm_horizontal</td>
<td class="fielddoc">
A pre-calculated value. </td></tr>
<tr><td class="fieldtype">
<a id="a0e2357d626c7b59c41b5ab7dd3897f5a"></a>float</td>
<td class="fieldname">
pixels_per_mm_vertical</td>
<td class="fielddoc">
A pre-calculated value. </td></tr>
<tr><td class="fieldtype">
<a id="a912b2876a44d9b57c97a3dcfdb2a6287"></a>int32_t</td>
<td class="fieldname">
refresh_mHz</td>
<td class="fielddoc">
The current refresh rate of the device. </td></tr>
<tr><td class="fieldtype">
<a id="ab5375d0b90c7a271e214825492ef25e2"></a>int32_t</td>
<td class="fieldname">
scale_factor</td>
<td class="fielddoc">
The scaling factor between the device and compositor. </td></tr>
<tr><td class="fieldtype">
<a id="acd506e1b19be3ee9838ac9359342ad3a"></a>int32_t</td>
<td class="fieldname">
subpixel</td>
<td class="fielddoc">
The device's subpixel orientation. </td></tr>
<tr><td class="fieldtype">
<a id="af5bdae9692e05be900ba2560682e9581"></a>int32_t</td>
<td class="fieldname">
transform</td>
<td class="fielddoc">
Transform that maps framebuffer to output. </td></tr>
<tr><td class="fieldtype">
<a id="a9945ea2b0dbc0afbe4a3af0cd4b3481b"></a>int32_t</td>
<td class="fieldname">
width</td>
<td class="fielddoc">
The width of the device in hardware units. </td></tr>
<tr><td class="fieldtype">
<a id="a94b47853e820f1e1719820fd8ffb7d0b"></a>int32_t</td>
<td class="fieldname">
x</td>
<td class="fielddoc">
The X position within the global compositor. </td></tr>
<tr><td class="fieldtype">
<a id="a41351a38b64d248924b2ab4cfa3170d3"></a>int32_t</td>
<td class="fieldname">
y</td>
<td class="fielddoc">
The Y position within the global compositor. </td></tr>
</table>

</div>
</div>
<a name="structzakero_1_1Yetani_1_1PointerAxis" id="structzakero_1_1Yetani_1_1PointerAxis"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structzakero_1_1Yetani_1_1PointerAxis">&#9670;&nbsp;</a></span>zakero::Yetani::PointerAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct zakero::Yetani::PointerAxis</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a1c4044eb951f9ca3ade85a9bcbae7660"></a>float</td>
<td class="fieldname">
distance</td>
<td class="fielddoc">
The distance traveled. </td></tr>
<tr><td class="fieldtype">
<a id="af34dc0d9f26ea2765fd60dffb3810bfd"></a><a class="el" href="classzakero_1_1Yetani.html#a58ba4ebcc1abb40b936d22821fe4daab">PointerAxisSource</a></td>
<td class="fieldname">
source</td>
<td class="fielddoc">
The source of the event. </td></tr>
<tr><td class="fieldtype">
<a id="ac44d001b4c651004769ab16af08fec27"></a>int32_t</td>
<td class="fieldname">
steps</td>
<td class="fielddoc">
The number of rotation steps. </td></tr>
<tr><td class="fieldtype">
<a id="a93d0826b7795abb32f82bb6e7f902285"></a>uint32_t</td>
<td class="fieldname">
time</td>
<td class="fielddoc">
When the event occurred. </td></tr>
<tr><td class="fieldtype">
<a id="a35a61d7d9f86a193da0b89b62f5cbd74"></a><a class="el" href="classzakero_1_1Yetani.html#a42274f7b4896cb3a82707a7659fba5f2">PointerAxisType</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
The type of Axis. </td></tr>
</table>

</div>
</div>
<a name="structzakero_1_1Yetani_1_1PointerButton" id="structzakero_1_1Yetani_1_1PointerButton"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structzakero_1_1Yetani_1_1PointerButton">&#9670;&nbsp;</a></span>zakero::Yetani::PointerButton</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct zakero::Yetani::PointerButton</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="af0524d9836aa6ad5f18a8904fa5d124e"></a>uint32_t</td>
<td class="fieldname">
code</td>
<td class="fielddoc">
The event code. </td></tr>
<tr><td class="fieldtype">
<a id="a43bf422769e8c7c9d6adc4ca2105be25"></a><a class="el" href="classzakero_1_1Yetani.html#a443f97670ca82036adb6684fcadef53b">PointerButtonState</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
The button state. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a904a1d471bf7a7d3bd7c2b3c067d4eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904a1d471bf7a7d3bd7c2b3c067d4eec">&#9670;&nbsp;</a></span>KeyState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classzakero_1_1Yetani.html#a904a1d471bf7a7d3bd7c2b3c067d4eec">zakero::Yetani::KeyState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When using a keyboard, a key will emit one of these states. </p>

</div>
</div>
<a id="ac2601eed0ec5db5e6117d26535a8e0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2601eed0ec5db5e6117d26535a8e0e6">&#9670;&nbsp;</a></span>WindowMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classzakero_1_1Yetani.html#ac2601eed0ec5db5e6117d26535a8e0e6">zakero::Yetani::WindowMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All the available window modes. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab9adae281d9541c70fc685069893a983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9adae281d9541c70fc685069893a983">&#9670;&nbsp;</a></span>~Yetani()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">zakero::Yetani::~Yetani </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deleting the <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> object will automatically disconnect from the Wayland server.</p>
<p>Because <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> is multithreaded, this method will block until all connections to Wayland have been closed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a61707e5ddf512891501b1d082a837d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61707e5ddf512891501b1d082a837d25">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani.html">Yetani</a> * zakero::Yetani::connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establish a connection with the Wayland Compositor. The following values will be used to determine which Wayland Compositor to connect to:</p><ol type="1">
<li><b>WAYLAND_DISPLAY</b><br  />
 Use the value of this environment variable.</li>
<li><b>"wayland-0"</b><br  />
 This is the default display name used by Wayland.</li>
</ol>
<p>If a connection was successful, then a pointer to a new <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> instance will be returned. This pointer will need to be <code>delete</code>d by the caller. If there was an error connecting to the Wayland Compositor, <code>nullptr</code> will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>A connection to the Wayland Compositor must be made before any windows are created.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> instance or a <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a102ed2ded260482cd3446d5c747239fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102ed2ded260482cd3446d5c747239fb">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani.html">Yetani</a> * zakero::Yetani::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establish a connection with the Wayland Compositor. The following values will be used to determine which Wayland Compositor to connect to:</p><ol type="1">
<li><code><b>display</b></code> <br  />
 If the value in not empty, this display name will be used.</li>
<li><b>WAYLAND_DISPLAY</b><br  />
 Use the value of this environment variable.</li>
<li><b>"wayland-0"</b><br  />
 This is the default display name used by Wayland.</li>
</ol>
<p>If a connection was successful, then a pointer to a new <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> instance will be returned. This pointer will need to be <code>delete</code>d by the caller. If there was an error connecting to the Wayland Compositor, <code>nullptr</code> will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>A connection to the Wayland Compositor must be made before any windows are created.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> instance or a <code>nullptr</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The Display Name or ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02ac4519a0eb85e9569a83ce7842d67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ac4519a0eb85e9569a83ce7842d67a">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani.html">Yetani</a> * zakero::Yetani::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establish a connection with the Wayland Compositor. The following values will be used to determine which Wayland Compositor to connect to:</p><ol type="1">
<li><code><b>display</b></code> <br  />
 If the value in not empty, this display name will be used.</li>
<li><b>WAYLAND_DISPLAY</b><br  />
 Use the value of this environment variable.</li>
<li><b>"wayland-0"</b><br  />
 This is the default display name used by Wayland.</li>
</ol>
<p>If a connection was successful, then a pointer to a new <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> instance will be returned. This pointer will need to be <code>delete</code>d by the caller. If there was an error connecting to the Wayland Compositor, <code>nullptr</code> will be returned.</p>
<p>The provided <code>error</code> will be set to Yetani::Error_None or the reason for the connection failure. An error code of <code>Yetani::Error_Connection_Failed</code> or <code>Yetani::Error_Invalid_Display_Name</code> may indicate that there is no Wayland Compositor available.</p>
<dl class="section note"><dt>Note</dt><dd>A connection to the Wayland Compositor must be made before any windows are created.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> instance or a <code>nullptr</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The Display Name or ID </td></tr>
    <tr><td class="paramname">error</td><td>The error status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4d38a2413361c8970b4c91998bb51f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d38a2413361c8970b4c91998bb51f1">&#9670;&nbsp;</a></span>connect() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani.html">Yetani</a> * zakero::Yetani::connect </td>
          <td>(</td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establish a connection with the Wayland Compositor. The following values will be used to determine which Wayland Compositor to connect to:</p><ol type="1">
<li><b>WAYLAND_DISPLAY</b><br  />
 Use the value of this environment variable.</li>
<li><b>"wayland-0"</b><br  />
 This is the default display name used by Wayland.</li>
</ol>
<p>If a connection was successful, then a pointer to a new <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> instance will be returned. This pointer will need to be <code>delete</code>d by the caller. If there was an error connecting to the Wayland Compositor, <code>nullptr</code> will be returned.</p>
<p>The provided <code>error</code> will be set to Yetani::Error_None or the reason for the connection failure. An error code of <code>Yetani::Error_Connection_Failed</code> or <code>Yetani::Error_Invalid_Display_Name</code> may indicate that there is no Wayland Compositor available.</p>
<dl class="section note"><dt>Note</dt><dd>A connection to the Wayland Compositor must be made before any windows are created.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classzakero_1_1Yetani.html" title="A wrapper class for Wayland.">Yetani</a> instance or a <code>nullptr</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63d0d4630a1e65ae93e6cc20d5fee4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d0d4630a1e65ae93e6cc20d5fee4f6">&#9670;&nbsp;</a></span>cursorCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code zakero::Yetani::cursorCreate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1CursorConfig">Yetani::CursorConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A cursor with the given <code>name</code> will be created. The <code>config</code> data will be used to determine how the cursor will be configured.</p>
<dl class="section user"><dt>Cursor Configuration</dt><dd><p class="startdd"></p>
<p class="interdd">The <a class="el" href="classzakero_1_1Yetani.html#a1ee8e27c543d504820f764005aa579e0" title="A collection of image data.">CursorConfig::image_data</a> holds the graphic image data for each frame of the cursor. If the cursor is not animated, then only one frame needs to be provided.</p>
<p class="interdd">Each frame of the cursor (including non-animated cursors, i.e.: a single frame) must have the dimension specified by <a class="el" href="classzakero_1_1Yetani.html#aa1ac798b2d51f3875328f2524d017c40" title="The size of the cursor.">CursorConfig::size</a>. And the data in each frame must conform to the value of <a class="el" href="classzakero_1_1Yetani.html#a824c2efa9c835cf0fb268f9b79a376ba" title="The pixel format.">CursorConfig::format</a>. The required amount of data for each frame is: <code>size_in_bytes = size.width * size.height * shmFormatBytesPerPixel(format)</code></p>
<p class="interdd">If more than one frame is provided in <a class="el" href="classzakero_1_1Yetani.html#a1ee8e27c543d504820f764005aa579e0" title="A collection of image data.">CursorConfig::image_data</a>, then the amount of time to display each frame must be placed in <a class="el" href="classzakero_1_1Yetani.html#a457a9bf3942ed18e9c96ee061f173c40" title="How long to display each frame of animation.">CursorConfig::time_per_frame</a>.</p>
<p class="interdd">Once the last frame of the cursor has been displayed, the first frame will be displayed next creating a continuous looping animation.</p>
<p class="enddd">Every cursor needs to have a spot that is used to determine where the pointer is located called a <em>hotspot</em>. The location of the hotspot is relative to the top-left corner (0x0) and should be assigned to <a class="el" href="classzakero_1_1Yetani.html#a6200a0bb358ab2adfb0f02709d4a6769" title="The X location of the hotspot.">CursorConfig::hotspot_x</a> and <a class="el" href="classzakero_1_1Yetani.html#a7b3e3b9c9b56db6c521df68bfc6933ec" title="The Y location of the hotspot.">CursorConfig::hotspot_y</a>. </p>
</dd></dl>
<p>If the configuration was valid and the cursor was successfully created, then <code>Yetani::Error_None</code> will be returned. Otherwise, another error will be returned to indicate the encountered problem.</p>
<dl class="section return"><dt>Returns</dt><dd>An error code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the cursor </td></tr>
    <tr><td class="paramname">config</td><td>The cursor configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e02d816f6d3c52ffbeea1abc7d1c457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e02d816f6d3c52ffbeea1abc7d1c457">&#9670;&nbsp;</a></span>cursorDestroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code zakero::Yetani::cursorDestroy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cursor with the specified <code>name</code> will be destroyed. If any windows are using the cursor, they will report an error.</p>
<dl class="section return"><dt>Returns</dt><dd>An error code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27cd01ea08eda690b256cf0665b5d892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cd01ea08eda690b256cf0665b5d892">&#9670;&nbsp;</a></span>keyRepeatDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t zakero::Yetani::keyRepeatDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <em>key repeat delay</em> is the amount of time in milliseconds that must elapse from a key press event to change into a key repeat event.</p>
<dl class="section return"><dt>Returns</dt><dd>The key repeat delay. </dd></dl>

</div>
</div>
<a id="a715553d39084a9b336ba1dae6f71b9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715553d39084a9b336ba1dae6f71b9be">&#9670;&nbsp;</a></span>keyRepeatRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t zakero::Yetani::keyRepeatRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <em>key repeat rate</em> is the number of key repeat events that will be emitted per second.</p>
<dl class="section return"><dt>Returns</dt><dd>The key repeat rate. </dd></dl>

</div>
</div>
<a id="a3d11478a780d9b57e86638ee1b296b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d11478a780d9b57e86638ee1b296b81">&#9670;&nbsp;</a></span>output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output">Yetani::Output</a> zakero::Yetani::output </td>
          <td>(</td>
          <td class="paramtype">const Yetani::OutputId&#160;</td>
          <td class="paramname"><em>output_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All the available information about an output device will be provided. It is possible that an output device is removed after the data has been retrieved, so consider the provided data as a "snapshot in time".</p>
<p>If the provided <code>output_id</code> is not valid, then the returned data will be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> data. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_id</td><td>The <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> Id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0adb15f54b21f19def68cea4be3b75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0adb15f54b21f19def68cea4be3b75a">&#9670;&nbsp;</a></span>outputConvertToMm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzakero_1_1Yetani_1_1PointMm.html">Yetani::PointMm</a> zakero::Yetani::outputConvertToMm </td>
          <td>(</td>
          <td class="paramtype">const Yetani::OutputId&#160;</td>
          <td class="paramname"><em>output_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a pixel-based <code>point</code> location to millimeters using the provided <code>output_id</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A point that uses millimeters. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_id</td><td>The output device for the conversion </td></tr>
    <tr><td class="paramname">point</td><td>The point to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a188bcaf0e6694e80876973f8abffd7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188bcaf0e6694e80876973f8abffd7b7">&#9670;&nbsp;</a></span>outputConvertToMm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> zakero::Yetani::outputConvertToMm </td>
          <td>(</td>
          <td class="paramtype">const Yetani::OutputId&#160;</td>
          <td class="paramname"><em>output_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a pixel-based <code>size</code> to millimeters using the provided <code>output_id</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A size that uses millimeters. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_id</td><td>The output device for the conversion </td></tr>
    <tr><td class="paramname">size</td><td>The size to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39b411cbfc021a3486b796bdb2a494e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b411cbfc021a3486b796bdb2a494e9">&#9670;&nbsp;</a></span>outputConvertToPercent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzakero_1_1Yetani_1_1PointPercent.html">Yetani::PointPercent</a> zakero::Yetani::outputConvertToPercent </td>
          <td>(</td>
          <td class="paramtype">const Yetani::OutputId&#160;</td>
          <td class="paramname"><em>output_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a pixel-based <code>point</code> location to a percentage using the provided <code>output_id</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A point that uses a percentage. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_id</td><td>The output device for the conversion </td></tr>
    <tr><td class="paramname">point</td><td>The point to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace580fc683773b95881248936fb450d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace580fc683773b95881248936fb450d9">&#9670;&nbsp;</a></span>outputConvertToPercent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> zakero::Yetani::outputConvertToPercent </td>
          <td>(</td>
          <td class="paramtype">const Yetani::OutputId&#160;</td>
          <td class="paramname"><em>output_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a pixel-based <code>size</code> to a percentage using the provided <code>output_id</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A size that uses a percentage. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_id</td><td>The output device for the conversion </td></tr>
    <tr><td class="paramname">size</td><td>The size to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a339bcf6d59d9fce37fe84ad6c0aafa43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339bcf6d59d9fce37fe84ad6c0aafa43">&#9670;&nbsp;</a></span>outputConvertToPixel() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a> zakero::Yetani::outputConvertToPixel </td>
          <td>(</td>
          <td class="paramtype">const Yetani::OutputId&#160;</td>
          <td class="paramname"><em>output_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1PointMm.html">Yetani::PointMm</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a millimeter-based <code>point</code> location to pixel using the provided <code>output_id</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A point that uses pixels. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_id</td><td>The output device for the conversion </td></tr>
    <tr><td class="paramname">point</td><td>The point to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed3097ba563e74ada5ea6a0a5fba95bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3097ba563e74ada5ea6a0a5fba95bb">&#9670;&nbsp;</a></span>outputConvertToPixel() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzakero_1_1Yetani_1_1PointPixel.html">Yetani::PointPixel</a> zakero::Yetani::outputConvertToPixel </td>
          <td>(</td>
          <td class="paramtype">const Yetani::OutputId&#160;</td>
          <td class="paramname"><em>output_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1PointPercent.html">Yetani::PointPercent</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a percentage-based <code>point</code> location to pixel using the provided <code>output_id</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A point that uses pixels. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_id</td><td>The output device for the conversion </td></tr>
    <tr><td class="paramname">point</td><td>The point to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c70746472ab4934f566a44862bcf1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c70746472ab4934f566a44862bcf1d6">&#9670;&nbsp;</a></span>outputConvertToPixel() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> zakero::Yetani::outputConvertToPixel </td>
          <td>(</td>
          <td class="paramtype">const Yetani::OutputId&#160;</td>
          <td class="paramname"><em>output_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a millimeter-based <code>size</code> to pixel using the provided <code>output_id</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A size that uses pixels. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_id</td><td>The output device for the conversion </td></tr>
    <tr><td class="paramname">size</td><td>The size to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3615f44aecf594b42d3b2666ed0f6735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3615f44aecf594b42d3b2666ed0f6735">&#9670;&nbsp;</a></span>outputConvertToPixel() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> zakero::Yetani::outputConvertToPixel </td>
          <td>(</td>
          <td class="paramtype">const Yetani::OutputId&#160;</td>
          <td class="paramname"><em>output_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a percentage-based <code>size</code> to pixel using the provided <code>output_id</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A size that uses pixels. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_id</td><td>The output device for the conversion </td></tr>
    <tr><td class="paramname">size</td><td>The size to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a327d74fb81899e02b0ba672cd6483d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327d74fb81899e02b0ba672cd6483d35">&#9670;&nbsp;</a></span>outputOnAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zakero::Yetani::outputOnAdd </td>
          <td>(</td>
          <td class="paramtype">Yetani::LambdaOutputId&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When a Wayland output device has been added, the <code>lambda</code> that was provided to this method will be called. To disable these notifications, pass <code>nullptr</code> as the value of <code>lambda</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>The lambda to call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4316c6cd8ee78599fdfbf348342d9f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4316c6cd8ee78599fdfbf348342d9f95">&#9670;&nbsp;</a></span>outputOnChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zakero::Yetani::outputOnChange </td>
          <td>(</td>
          <td class="paramtype">Yetani::LambdaOutputId&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When a Wayland output device's configuration has been changed, the <code>lambda</code> that was provided to this method will be called. To disable these notifications, pass <code>nullptr</code> as the value of <code>lambda</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>The lambda to call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a567ad366591e5a067d5c54b503db9348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567ad366591e5a067d5c54b503db9348">&#9670;&nbsp;</a></span>outputOnRemove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zakero::Yetani::outputOnRemove </td>
          <td>(</td>
          <td class="paramtype">Yetani::LambdaOutputId&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When a Wayland output device has been removed, the <code>lambda</code> that was provided to this method will be called. To disable these notifications, pass <code>nullptr</code> as the value of <code>lambda</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>The lambda to call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ebe046061081cffa084ef3afae92d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebe046061081cffa084ef3afae92d92">&#9670;&nbsp;</a></span>outputSubpixelName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::Yetani::outputSubpixelName </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>subpixel_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <code><a class="el" href="classzakero_1_1Yetani.html#acd506e1b19be3ee9838ac9359342ad3a" title="The device&#39;s subpixel orientation.">Yetani::Output::subpixel</a></code> is a Wayland enum value and this method will convert that value into a descriptive name string. If an invalid value is passed, then an empty string will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The name of the subpixel format. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subpixel_format</td><td>The Subpixel format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0aad71992f986b026a730a1dc064222e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aad71992f986b026a730a1dc064222e">&#9670;&nbsp;</a></span>outputTransformName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::Yetani::outputTransformName </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <code><a class="el" href="classzakero_1_1Yetani.html#af5bdae9692e05be900ba2560682e9581" title="Transform that maps framebuffer to output.">Yetani::Output::transform</a></code> is a Wayland enum value and this method will convert that value into a descriptive name string. If an invalid value is passed, then an empty string will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The name of the transform. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21a442911a60e62ea5c163b3c3b5a894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a442911a60e62ea5c163b3c3b5a894">&#9670;&nbsp;</a></span>outputVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Yetani::VectorOutputId zakero::Yetani::outputVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All the <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> IDs will be returned. It is possible that an output device is removed after the data has been retrieved, so consider the provided data as a "snapshot in time".</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classzakero_1_1Yetani.html#structzakero_1_1Yetani_1_1Output" title="Information about a output device.">Output</a> Id's. </dd></dl>

</div>
</div>
<a id="a7c51a51c7a126cc32dcf5c3a6c6bbb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c51a51c7a126cc32dcf5c3a6c6bbb6b">&#9670;&nbsp;</a></span>shmFormatAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Yetani::VectorShmFormat &amp; zakero::Yetani::shmFormatAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All of the supported wl_shm_format values, color formats, are provided in the returned container.</p>
<dl class="section return"><dt>Returns</dt><dd>The supported formats. </dd></dl>

</div>
</div>
<a id="ad5431d29ccb5f6c8b248ca74e209b5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5431d29ccb5f6c8b248ca74e209b5cc">&#9670;&nbsp;</a></span>shmFormatBytesPerPixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t zakero::Yetani::shmFormatBytesPerPixel </td>
          <td>(</td>
          <td class="paramtype">const wl_shm_format&#160;</td>
          <td class="paramname"><em>shm_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When allocating buffers in Wayland, the number of bytes required per pixel is important so that the correct amount of memory is known. This method will determine the bytes-per-pixel based on the provided <code>shm_format</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes-per-pixel </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shm_format</td><td>The format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7bcc5ee2e3eb29b9e5690245f8f9741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bcc5ee2e3eb29b9e5690245f8f9741">&#9670;&nbsp;</a></span>shmFormatDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::Yetani::shmFormatDescription </td>
          <td>(</td>
          <td class="paramtype">const wl_shm_format&#160;</td>
          <td class="paramname"><em>shm_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In the documented code of Wayland, there are descriptions for each of the supported color formats. By providing the <code>shm_format</code>, the description of the format will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>A description </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shm_format</td><td>The format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21773e27cac9c0d7c09bab553f7ec7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21773e27cac9c0d7c09bab553f7ec7d9">&#9670;&nbsp;</a></span>shmFormatName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::Yetani::shmFormatName </td>
          <td>(</td>
          <td class="paramtype">const wl_shm_format&#160;</td>
          <td class="paramname"><em>shm_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the enum name of the <code>shm_format</code> to a string.</p>
<dl class="section return"><dt>Returns</dt><dd>The name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shm_format</td><td>The format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac40a22e06b3f05cbf3a83e88c3019acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40a22e06b3f05cbf3a83e88c3019acb">&#9670;&nbsp;</a></span>windowCreate() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> * zakero::Yetani::windowCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wl_shm_format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> of the specified <code>size</code>. A pointer to the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will be returned. If there was a problem, a <code>nullptr</code> will returned.</p>
<p>The shared memory used by the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will use the pixel <code>format</code>.</p>
<p>The <code>error</code> parameter will be set to Yetani::Error_None on success or to an appropriate error if there was a problem.</p>
<dl class="section note"><dt>Note</dt><dd>The size of a window <b>must</b> be greater than <code>0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> or <code>nullptr</code> on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The window size </td></tr>
    <tr><td class="paramname">format</td><td>The pixel format </td></tr>
    <tr><td class="paramname">error</td><td>The error state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5c0ff718af6c02ae63d2fcad158548a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c0ff718af6c02ae63d2fcad158548a">&#9670;&nbsp;</a></span>windowCreate() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> * zakero::Yetani::windowCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wl_shm_format&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="classzakero_1_1Yetani.html#a4f0707f559705cee3789766694a00821">SHM_FORMAT_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> of the specified <code>size</code>. A pointer to the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will be returned. If there was a problem, a <code>nullptr</code> will returned.</p>
<p>The shared memory used by the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will use the pixel <code>format</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The size of a window <b>must</b> be greater than <code>0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> or <code>nullptr</code> on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The window size </td></tr>
    <tr><td class="paramname">format</td><td>The pixel format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a419c666f48108c08bd666d1dbf2a534b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419c666f48108c08bd666d1dbf2a534b">&#9670;&nbsp;</a></span>windowCreate() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> * zakero::Yetani::windowCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizeMm.html">Yetani::SizeMm</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> of the specified <code>size</code>. A pointer to the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will be returned. If there was a problem, a <code>nullptr</code> will returned.</p>
<p>The <code>error</code> parameter will be set to Yetani::Error_None on success or to an appropriate error if there was a problem.</p>
<dl class="section note"><dt>Note</dt><dd>The size of a window <b>must</b> be greater than <code>0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> or <code>nullptr</code> on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The window size </td></tr>
    <tr><td class="paramname">error</td><td>The error state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03f63e54c86fc840e2e8e136cceed983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f63e54c86fc840e2e8e136cceed983">&#9670;&nbsp;</a></span>windowCreate() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> * zakero::Yetani::windowCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wl_shm_format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> of the specified <code>size</code>. A pointer to the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will be returned. If there was a problem, a <code>nullptr</code> will returned.</p>
<p>The shared memory used by the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will use the pixel <code>format</code>.</p>
<p>The <code>error</code> parameter will be set to Yetani::Error_None on success or to an appropriate error if there was a problem.</p>
<dl class="section note"><dt>Note</dt><dd>The size of a window <b>must</b> be greater than <code>0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> or <code>nullptr</code> on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The window size </td></tr>
    <tr><td class="paramname">format</td><td>The pixel format </td></tr>
    <tr><td class="paramname">error</td><td>The error state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5eb5293e84859f8b2ab3e266a5f0ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eb5293e84859f8b2ab3e266a5f0ee9">&#9670;&nbsp;</a></span>windowCreate() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> * zakero::Yetani::windowCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wl_shm_format&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="classzakero_1_1Yetani.html#a4f0707f559705cee3789766694a00821">SHM_FORMAT_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> of the specified <code>size</code>. A pointer to the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will be returned. If there was a problem, a <code>nullptr</code> will returned.</p>
<p>The shared memory used by the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will use the pixel <code>format</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The size of a window <b>must</b> be greater than <code>0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> or <code>nullptr</code> on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The window size </td></tr>
    <tr><td class="paramname">format</td><td>The pixel format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42a41c39af298cad3c8e2d3e71a6be21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a41c39af298cad3c8e2d3e71a6be21">&#9670;&nbsp;</a></span>windowCreate() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> * zakero::Yetani::windowCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizePercent.html">Yetani::SizePercent</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> of the specified <code>size</code>. A pointer to the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will be returned. If there was a problem, a <code>nullptr</code> will returned.</p>
<p>The <code>error</code> parameter will be set to Yetani::Error_None on success or to an appropriate error if there was a problem.</p>
<dl class="section note"><dt>Note</dt><dd>The size of a window <b>must</b> be greater than <code>0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> or <code>nullptr</code> on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The window size </td></tr>
    <tr><td class="paramname">error</td><td>The error state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa5b59695086f17d14da37f734ec45f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5b59695086f17d14da37f734ec45f5">&#9670;&nbsp;</a></span>windowCreate() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> * zakero::Yetani::windowCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wl_shm_format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> of the specified <code>size</code>. A pointer to the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will be returned. If there was a problem, a <code>nullptr</code> will returned.</p>
<p>The shared memory used by the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will use the pixel <code>format</code>.</p>
<p>The <code>error</code> parameter will be set to Yetani::Error_None on success or to an appropriate error if there was a problem.</p>
<dl class="section note"><dt>Note</dt><dd>The size of a window <b>must</b> be greater than <code>0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> or <code>nullptr</code> on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The window size </td></tr>
    <tr><td class="paramname">format</td><td>The pixel format </td></tr>
    <tr><td class="paramname">error</td><td>The error state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedce34d1ba2bc817cc509c54101458c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedce34d1ba2bc817cc509c54101458c2">&#9670;&nbsp;</a></span>windowCreate() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> * zakero::Yetani::windowCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wl_shm_format&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="classzakero_1_1Yetani.html#a4f0707f559705cee3789766694a00821">SHM_FORMAT_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> of the specified <code>size</code>. A pointer to the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will be returned. If there was a problem, a <code>nullptr</code> will returned.</p>
<p>The shared memory used by the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will use the pixel <code>format</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The size of a window <b>must</b> be greater than <code>0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> or <code>nullptr</code> on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The window size </td></tr>
    <tr><td class="paramname">format</td><td>The pixel format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd77d5527582bb006db4e2d2002aa841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd77d5527582bb006db4e2d2002aa841">&#9670;&nbsp;</a></span>windowCreate() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzakero_1_1Yetani_1_1Window.html">Yetani::Window</a> * zakero::Yetani::windowCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structzakero_1_1Yetani_1_1SizePixel.html">Yetani::SizePixel</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> of the specified <code>size</code>. A pointer to the <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> will be returned. If there was a problem, a <code>nullptr</code> will returned.</p>
<p>The <code>error</code> parameter will be set to Yetani::Error_None on success or to an appropriate error if there was a problem.</p>
<dl class="section note"><dt>Note</dt><dd>The size of a window <b>must</b> be greater than <code>0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classzakero_1_1Yetani_1_1Window.html" title="A Window.">Window</a> or <code>nullptr</code> on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The window size </td></tr>
    <tr><td class="paramname">error</td><td>The error state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Zakero__Yetani_8h_source.html">Zakero_Yetani.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
