<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zakero&#39;s C++ Header Libraries: zakero::MemoryPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zakero&#39;s C++ Header Libraries
   </div>
   <div id="projectbrief">A collection of reusable C++ libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>zakero</b></li><li class="navelem"><a class="el" href="classzakero_1_1_memory_pool.html">MemoryPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classzakero_1_1_memory_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">zakero::MemoryPool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A pool of memory.  
 <a href="classzakero_1_1_memory_pool.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6d1fb194cf769f26b7773ded7c18f954"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a6d1fb194cf769f26b7773ded7c18f954">Alignment</a> : uint8_t </td></tr>
<tr class="memdesc:a6d1fb194cf769f26b7773ded7c18f954"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Byte-Alignment of the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a>.  <a href="classzakero_1_1_memory_pool.html#a6d1fb194cf769f26b7773ded7c18f954">More...</a><br /></td></tr>
<tr class="separator:a6d1fb194cf769f26b7773ded7c18f954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9291872c2c7b3063a32d0a05408944"><td class="memItemLeft" align="right" valign="top"><a id="a5e9291872c2c7b3063a32d0a05408944"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a5e9291872c2c7b3063a32d0a05408944">AddressMap</a> = std::map&lt; uint8_t *, uint8_t * &gt;</td></tr>
<tr class="memdesc:a5e9291872c2c7b3063a32d0a05408944"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping of old addresses to new addresses. <br /></td></tr>
<tr class="separator:a5e9291872c2c7b3063a32d0a05408944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a72834586ae1751ad4d22e421cb307"><td class="memItemLeft" align="right" valign="top"><a id="a06a72834586ae1751ad4d22e421cb307"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a06a72834586ae1751ad4d22e421cb307">LambdaSize</a> = std::function&lt; void(size_t)&gt;</td></tr>
<tr class="memdesc:a06a72834586ae1751ad4d22e421cb307"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lambda that receives a <code>size_t</code> argument. <br /></td></tr>
<tr class="separator:a06a72834586ae1751ad4d22e421cb307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af684a6a80921ce92404f9f2d4bdb03ea"><td class="memItemLeft" align="right" valign="top"><a id="af684a6a80921ce92404f9f2d4bdb03ea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#af684a6a80921ce92404f9f2d4bdb03ea">LambdaAddressMap</a> = std::function&lt; void(const <a class="el" href="classzakero_1_1_memory_pool.html#a5e9291872c2c7b3063a32d0a05408944">MemoryPool::AddressMap</a> &amp;)&gt;</td></tr>
<tr class="memdesc:af684a6a80921ce92404f9f2d4bdb03ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lambda that receives a <a class="el" href="classzakero_1_1_memory_pool.html#a5e9291872c2c7b3063a32d0a05408944" title="A mapping of old addresses to new addresses.">MemoryPool::AddressMap</a>. <br /></td></tr>
<tr class="separator:af684a6a80921ce92404f9f2d4bdb03ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aebc36a9036be655d221b7f34ea146b47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#aebc36a9036be655d221b7f34ea146b47">MemoryPool</a> (const std::string &amp;) noexcept</td></tr>
<tr class="memdesc:aebc36a9036be655d221b7f34ea146b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classzakero_1_1_memory_pool.html#aebc36a9036be655d221b7f34ea146b47">More...</a><br /></td></tr>
<tr class="separator:aebc36a9036be655d221b7f34ea146b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3004431c0df6528596f4de48d60963a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a3004431c0df6528596f4de48d60963a1">~MemoryPool</a> () noexcept</td></tr>
<tr class="memdesc:a3004431c0df6528596f4de48d60963a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classzakero_1_1_memory_pool.html#a3004431c0df6528596f4de48d60963a1">More...</a><br /></td></tr>
<tr class="separator:a3004431c0df6528596f4de48d60963a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dda3203fc80b7c711f74032a1b86157"><td class="memItemLeft" align="right" valign="top">std::error_condition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a9dda3203fc80b7c711f74032a1b86157">init</a> (size_t, const bool=false, const <a class="el" href="classzakero_1_1_memory_pool.html#a6d1fb194cf769f26b7773ded7c18f954">MemoryPool::Alignment</a>=MemoryPool::Alignment::Bits_64) noexcept</td></tr>
<tr class="memdesc:a9dda3203fc80b7c711f74032a1b86157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a>.  <a href="classzakero_1_1_memory_pool.html#a9dda3203fc80b7c711f74032a1b86157">More...</a><br /></td></tr>
<tr class="separator:a9dda3203fc80b7c711f74032a1b86157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fa5532f650637172a31b58684cc329"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a99fa5532f650637172a31b58684cc329">fd</a> () const noexcept</td></tr>
<tr class="memdesc:a99fa5532f650637172a31b58684cc329"><td class="mdescLeft">&#160;</td><td class="mdescRight">The backing file descriptor.  <a href="classzakero_1_1_memory_pool.html#a99fa5532f650637172a31b58684cc329">More...</a><br /></td></tr>
<tr class="separator:a99fa5532f650637172a31b58684cc329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794a2098e0cb093647fe01e3bd241583"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a794a2098e0cb093647fe01e3bd241583">size</a> () const noexcept</td></tr>
<tr class="memdesc:a794a2098e0cb093647fe01e3bd241583"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the memory pool.  <a href="classzakero_1_1_memory_pool.html#a794a2098e0cb093647fe01e3bd241583">More...</a><br /></td></tr>
<tr class="separator:a794a2098e0cb093647fe01e3bd241583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e6f78193fd77dbfea0d8115403b830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#ac0e6f78193fd77dbfea0d8115403b830">sizeOnChange</a> (<a class="el" href="classzakero_1_1_memory_pool.html#a06a72834586ae1751ad4d22e421cb307">MemoryPool::LambdaSize</a>) noexcept</td></tr>
<tr class="memdesc:ac0e6f78193fd77dbfea0d8115403b830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Size Event callback.  <a href="classzakero_1_1_memory_pool.html#ac0e6f78193fd77dbfea0d8115403b830">More...</a><br /></td></tr>
<tr class="separator:ac0e6f78193fd77dbfea0d8115403b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d7b50379901e82523b5f58aa776151"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a32d7b50379901e82523b5f58aa776151">alloc</a> (size_t) noexcept</td></tr>
<tr class="memdesc:a32d7b50379901e82523b5f58aa776151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from the pool.  <a href="classzakero_1_1_memory_pool.html#a32d7b50379901e82523b5f58aa776151">More...</a><br /></td></tr>
<tr class="separator:a32d7b50379901e82523b5f58aa776151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9155d4c94688dee0adb87e4d6cce237c"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a9155d4c94688dee0adb87e4d6cce237c">alloc</a> (size_t, std::error_condition &amp;) noexcept</td></tr>
<tr class="memdesc:a9155d4c94688dee0adb87e4d6cce237c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from the pool.  <a href="classzakero_1_1_memory_pool.html#a9155d4c94688dee0adb87e4d6cce237c">More...</a><br /></td></tr>
<tr class="separator:a9155d4c94688dee0adb87e4d6cce237c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51813d4ababa76c842d0d7cb12a5509"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#ad51813d4ababa76c842d0d7cb12a5509">alloc</a> (size_t, uint8_t) noexcept</td></tr>
<tr class="memdesc:ad51813d4ababa76c842d0d7cb12a5509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from the pool.  <a href="classzakero_1_1_memory_pool.html#ad51813d4ababa76c842d0d7cb12a5509">More...</a><br /></td></tr>
<tr class="separator:ad51813d4ababa76c842d0d7cb12a5509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658567c32596ba4da7d68e6cdac6ad6"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a6658567c32596ba4da7d68e6cdac6ad6">alloc</a> (size_t, uint8_t, std::error_condition &amp;) noexcept</td></tr>
<tr class="memdesc:a6658567c32596ba4da7d68e6cdac6ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from the pool.  <a href="classzakero_1_1_memory_pool.html#a6658567c32596ba4da7d68e6cdac6ad6">More...</a><br /></td></tr>
<tr class="separator:a6658567c32596ba4da7d68e6cdac6ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848efcff70300b6475300ae884635150"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a848efcff70300b6475300ae884635150">alloc</a> (size_t, uint32_t) noexcept</td></tr>
<tr class="memdesc:a848efcff70300b6475300ae884635150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from the pool.  <a href="classzakero_1_1_memory_pool.html#a848efcff70300b6475300ae884635150">More...</a><br /></td></tr>
<tr class="separator:a848efcff70300b6475300ae884635150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0bfa5f24a536035c4f4b011b0e3df1"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a0d0bfa5f24a536035c4f4b011b0e3df1">alloc</a> (size_t, uint32_t, std::error_condition &amp;) noexcept</td></tr>
<tr class="memdesc:a0d0bfa5f24a536035c4f4b011b0e3df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from the pool.  <a href="classzakero_1_1_memory_pool.html#a0d0bfa5f24a536035c4f4b011b0e3df1">More...</a><br /></td></tr>
<tr class="separator:a0d0bfa5f24a536035c4f4b011b0e3df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d20c34a90c6dc856fa3bbe0c53c0930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a2d20c34a90c6dc856fa3bbe0c53c0930">free</a> (off_t &amp;) noexcept</td></tr>
<tr class="memdesc:a2d20c34a90c6dc856fa3bbe0c53c0930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory.  <a href="classzakero_1_1_memory_pool.html#a2d20c34a90c6dc856fa3bbe0c53c0930">More...</a><br /></td></tr>
<tr class="separator:a2d20c34a90c6dc856fa3bbe0c53c0930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300f5ca9df6fdb12aab61f832e04d308"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a300f5ca9df6fdb12aab61f832e04d308">resize</a> (off_t, size_t) noexcept</td></tr>
<tr class="memdesc:a300f5ca9df6fdb12aab61f832e04d308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of allocated memory.  <a href="classzakero_1_1_memory_pool.html#a300f5ca9df6fdb12aab61f832e04d308">More...</a><br /></td></tr>
<tr class="separator:a300f5ca9df6fdb12aab61f832e04d308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b52c606d65ae8ef344f59e1fee3713"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#ab2b52c606d65ae8ef344f59e1fee3713">resize</a> (off_t, size_t, std::error_condition &amp;) noexcept</td></tr>
<tr class="memdesc:ab2b52c606d65ae8ef344f59e1fee3713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of allocated memory.  <a href="classzakero_1_1_memory_pool.html#ab2b52c606d65ae8ef344f59e1fee3713">More...</a><br /></td></tr>
<tr class="separator:ab2b52c606d65ae8ef344f59e1fee3713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdd1e2ac1a8bb8e4fb80eb9124d4c4d"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#abcdd1e2ac1a8bb8e4fb80eb9124d4c4d">addressOf</a> (off_t) const noexcept</td></tr>
<tr class="memdesc:abcdd1e2ac1a8bb8e4fb80eb9124d4c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an offset into a pointer.  <a href="classzakero_1_1_memory_pool.html#abcdd1e2ac1a8bb8e4fb80eb9124d4c4d">More...</a><br /></td></tr>
<tr class="separator:abcdd1e2ac1a8bb8e4fb80eb9124d4c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec529192bf00ca0ea535c4cbc81c082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#adec529192bf00ca0ea535c4cbc81c082">onRemap</a> (<a class="el" href="classzakero_1_1_memory_pool.html#af684a6a80921ce92404f9f2d4bdb03ea">MemoryPool::LambdaAddressMap</a>) noexcept</td></tr>
<tr class="memdesc:adec529192bf00ca0ea535c4cbc81c082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Remap Event callback.  <a href="classzakero_1_1_memory_pool.html#adec529192bf00ca0ea535c4cbc81c082">More...</a><br /></td></tr>
<tr class="separator:adec529192bf00ca0ea535c4cbc81c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1c70a04bdfdb706989757e5d72c1cf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#a0b1c70a04bdfdb706989757e5d72c1cf">dump</a> (size_t, size_t) const noexcept</td></tr>
<tr class="memdesc:a0b1c70a04bdfdb706989757e5d72c1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the internal state.  <a href="classzakero_1_1_memory_pool.html#a0b1c70a04bdfdb706989757e5d72c1cf">More...</a><br /></td></tr>
<tr class="separator:a0b1c70a04bdfdb706989757e5d72c1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac79e330bb9ba2d1d21218f7b463cbfae"><td class="memItemLeft" align="right" valign="top">static uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzakero_1_1_memory_pool.html#ac79e330bb9ba2d1d21218f7b463cbfae">remap</a> (const <a class="el" href="classzakero_1_1_memory_pool.html#a5e9291872c2c7b3063a32d0a05408944">MemoryPool::AddressMap</a> &amp;, uint8_t *) noexcept</td></tr>
<tr class="memdesc:ac79e330bb9ba2d1d21218f7b463cbfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the new memory address.  <a href="classzakero_1_1_memory_pool.html#ac79e330bb9ba2d1d21218f7b463cbfae">More...</a><br /></td></tr>
<tr class="separator:ac79e330bb9ba2d1d21218f7b463cbfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Refer to <a class="el" href="_zakero___memory_pool_8h.html" title="Zakero MemoryPool.">Zakero_MemoryPool.h</a> to learn how to include this library.</p>
<p>This object will create a region of memory and provide an interface to allocate from that memory. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6d1fb194cf769f26b7773ded7c18f954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1fb194cf769f26b7773ded7c18f954">&#9670;&nbsp;</a></span>Alignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classzakero_1_1_memory_pool.html#a6d1fb194cf769f26b7773ded7c18f954">zakero::MemoryPool::Alignment</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When allocating memory from the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a>, this enum determines which byte-boundary will be used. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aebc36a9036be655d221b7f34ea146b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc36a9036be655d221b7f34ea146b47">&#9670;&nbsp;</a></span>MemoryPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">zakero::MemoryPool::MemoryPool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new instance of the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a>. The provide file <code>name</code> is not the name of a file on the file system. The file <code>name</code> will only exist in RAM with an optional backing store in swap in available.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;The name of the MemoryPool&quot;</span>);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3004431c0df6528596f4de48d60963a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3004431c0df6528596f4de48d60963a1">&#9670;&nbsp;</a></span>~MemoryPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">zakero::MemoryPool::~MemoryPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release all allocated resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9dda3203fc80b7c711f74032a1b86157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dda3203fc80b7c711f74032a1b86157">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::error_condition zakero::MemoryPool::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>expandable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classzakero_1_1_memory_pool.html#a6d1fb194cf769f26b7773ded7c18f954">MemoryPool::Alignment</a>&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>MemoryPool::Alignment::Bits_64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> must be initialized before it can be used. At a minimum, the size of the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> must be specified in bytes.</p>
<p>The maximum allowable size is MemoryPool::Size_Max which represents the largest offset value supported by the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a>. Your hardware configuration and/or operating system may lower this limit.</p>
<p>Setting the <code>expandable</code> flag to <code>true</code> will allow the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> to grow to a larger size. If an allocation request is made that is larger that the largest available contiguous space available, then the Memory Pool will expand just enough to accommodate the request.</p>
<p>The Byte Boundary of all the allocations for this <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> object is specified by the <code>alignment</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The size of the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> will never shrink.</dd></dl>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> rgba_textures(<span class="stringliteral">&quot;Active Texture Cache&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define KILOBYETS(size_) ((size_) * 1024)</span></div>
<div class="line"><span class="preprocessor">#define MEGABYTES(size_) (KILOBYTES(size_) * 1024)</span></div>
<div class="line">rgba_textures.init(MEGABYTES(32)</div>
<div class="line">        , <span class="keyword">false</span> <span class="comment">// Restricted environment, no expanding</span></div>
<div class="line">        , zakero::MemoryPool::Alignment::Bits_32 <span class="comment">// RGBA == 32 bits</span></div>
<div class="line">        );</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>An error condition. If there was no error, then the value of the error condition will be <code>0</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The initial size in bytes </td></tr>
    <tr><td class="paramname">expandable</td><td>Allow the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> to expand </td></tr>
    <tr><td class="paramname">alignment</td><td>The Byte Alignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99fa5532f650637172a31b58684cc329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fa5532f650637172a31b58684cc329">&#9670;&nbsp;</a></span>fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int zakero::MemoryPool::fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If something needs to be able to map the same region of memory as this <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a>, then this method will provide the file descriptor to do it.</p>
<p>The entire <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> will be accessible from the file descriptor.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><span class="comment">// Get read access to the shared memory</span></div>
<div class="line">uint8_t* mem_reader = (uint8_t*)mmap(<span class="keyword">nullptr</span></div>
<div class="line">        , memory_pool.size()</div>
<div class="line">        , PROT_READ</div>
<div class="line">        , MAP_SHARED | MAP_NORESERVE</div>
<div class="line">        , memory_pool.fd()</div>
<div class="line">        );</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classzakero_1_1_memory_pool.html#a794a2098e0cb093647fe01e3bd241583" title="The size of the memory pool.">MemoryPool::size()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The file descriptor. </dd></dl>

</div>
</div>
<a id="a794a2098e0cb093647fe01e3bd241583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794a2098e0cb093647fe01e3bd241583">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t zakero::MemoryPool::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current size of the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a>, in bytes, will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the memory pool. </dd></dl>

</div>
</div>
<a id="ac0e6f78193fd77dbfea0d8115403b830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e6f78193fd77dbfea0d8115403b830">&#9670;&nbsp;</a></span>sizeOnChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zakero::MemoryPool::sizeOnChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classzakero_1_1_memory_pool.html#a06a72834586ae1751ad4d22e421cb307">MemoryPool::LambdaSize</a>&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> was configured to be able to dynamically expand as needed (see <a class="el" href="classzakero_1_1_memory_pool.html#a9dda3203fc80b7c711f74032a1b86157" title="Initialize the MemoryPool.">init()</a>), then the provided <code>lambda</code> will be called when the memory pool changes size. Using the <a class="el" href="classzakero_1_1_memory_pool.html#ac0e6f78193fd77dbfea0d8115403b830" title="Set the Size Event callback.">sizeOnChange()</a> method before calling <a class="el" href="classzakero_1_1_memory_pool.html#a9dda3203fc80b7c711f74032a1b86157" title="Initialize the MemoryPool.">init()</a> will not cause the lambda to be executed when <a class="el" href="classzakero_1_1_memory_pool.html#a9dda3203fc80b7c711f74032a1b86157" title="Initialize the MemoryPool.">init()</a> is called.</p>
<p>The <code>lambda</code> will receive the new size, in bytes, of the memory pool.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;Size Matters&quot;</span>);</div>
<div class="line"> </div>
<div class="line">memory_pool.init(1, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">memory_pool.sizeOnChange([](<span class="keywordtype">size_t</span> new_size)</div>
<div class="line">{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Size: &quot;</span> &lt;&lt; <span class="keywordtype">size_t</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">off_t uno = memory_pool.alloc(256);</div>
<div class="line">off_t dos = memory_pool.alloc(512);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> will be in a "locked state" so any call from the lambda to a non-const <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> method will block indefinitely. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>The callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32d7b50379901e82523b5f58aa776151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d7b50379901e82523b5f58aa776151">&#9670;&nbsp;</a></span>alloc() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">off_t zakero::MemoryPool::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The requested <code>size</code> (in bytes) will be allocated from the memory pool. If the memory could not be allocated, then <code>-1</code> will be returned.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">memory_pool.init(1024);</div>
<div class="line"> </div>
<div class="line">off_t data_offset = memory_pool.alloc(128);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The contents of the memory is undefined.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The offset of the block of memory. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9155d4c94688dee0adb87e4d6cce237c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9155d4c94688dee0adb87e4d6cce237c">&#9670;&nbsp;</a></span>alloc() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">off_t zakero::MemoryPool::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_condition &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The requested <code>size</code> (in bytes) will be allocated from the memory pool. If the memory could not be allocated, then <code>-1</code> will be returned and the reason will be stored in <code>error</code>.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">memory_pool.init(1024);</div>
<div class="line"> </div>
<div class="line">std::error_condition error;</div>
<div class="line">off_t data_offset = memory_pool.alloc(512, error);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(error.value() != 0)</div>
<div class="line">{</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; error.message() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The contents of the memory is undefined.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The offset of the block of memory. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes </td></tr>
    <tr><td class="paramname">error</td><td>The error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad51813d4ababa76c842d0d7cb12a5509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51813d4ababa76c842d0d7cb12a5509">&#9670;&nbsp;</a></span>alloc() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">off_t zakero::MemoryPool::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The requested <code>size</code> (in bytes) will be allocated from the memory pool. If the memory could not be allocated, then <code>-1</code> will be returned.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">memory_pool.init(1024);</div>
<div class="line"> </div>
<div class="line">off_t data_offset = memory_pool.alloc(512, uint8_t(0xa5));</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The offset of the block of memory. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes </td></tr>
    <tr><td class="paramname">value</td><td>The fill value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6658567c32596ba4da7d68e6cdac6ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6658567c32596ba4da7d68e6cdac6ad6">&#9670;&nbsp;</a></span>alloc() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">off_t zakero::MemoryPool::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_condition &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The requested <code>size</code> (in bytes) will be allocated from the memory pool. If the memory could not be allocated, then <code>-1</code> will be returned and the reason will be stored in <code>error</code>.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">memory_pool.init(1024);</div>
<div class="line"> </div>
<div class="line">std::error_condition error;</div>
<div class="line">off_t data_offset = memory_pool.alloc(512, uint8_t(0xa5), error);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(error.value() != 0)</div>
<div class="line">{</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; error.message() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The offset of the block of memory. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes </td></tr>
    <tr><td class="paramname">value</td><td>The fill value </td></tr>
    <tr><td class="paramname">error</td><td>The error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a848efcff70300b6475300ae884635150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848efcff70300b6475300ae884635150">&#9670;&nbsp;</a></span>alloc() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">off_t zakero::MemoryPool::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The requested <code>size</code> (in bytes) will be allocated from the memory pool. If the memory could not be allocated, then <code>-1</code> will be returned.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">memory_pool.init(1024);</div>
<div class="line"> </div>
<div class="line">off_t data_offset = memory_pool.alloc(512, uint32_t(0xa5));</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The offset of the block of memory. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes </td></tr>
    <tr><td class="paramname">value</td><td>The fill value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d0bfa5f24a536035c4f4b011b0e3df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0bfa5f24a536035c4f4b011b0e3df1">&#9670;&nbsp;</a></span>alloc() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">off_t zakero::MemoryPool::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_condition &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The requested <code>size</code> (in bytes) will be allocated from the memory pool. If the memory could not be allocated, then <code>-1</code> will be returned and the reason will be stored in <code>error</code>.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">memory_pool.init(1024);</div>
<div class="line"> </div>
<div class="line">std::error_condition error;</div>
<div class="line">off_t data_offset = memory_pool.alloc(512, uint32_t(0xa5), error);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(error.value() != 0)</div>
<div class="line">{</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; error.message() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The offset of the block of memory. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in bytes </td></tr>
    <tr><td class="paramname">value</td><td>The fill value </td></tr>
    <tr><td class="paramname">error</td><td>The error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d20c34a90c6dc856fa3bbe0c53c0930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d20c34a90c6dc856fa3bbe0c53c0930">&#9670;&nbsp;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zakero::MemoryPool::free </td>
          <td>(</td>
          <td class="paramtype">off_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The allocated memory at the provided <code>offset</code> will be free'ed. The <code>offset</code> will be set to <code>-1</code>.</p>
<p>If the <code>offset</code> is not valid, its value will not be changed.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;A Memory Pool&quot;</span>);</div>
<div class="line"> </div>
<div class="line">memory_pool.init(128);</div>
<div class="line"> </div>
<div class="line">off_t offset = memory_pool.alloc(64);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do stuff with offset</span></div>
<div class="line"> </div>
<div class="line">memory_pool.free(offset);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The memory to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a300f5ca9df6fdb12aab61f832e04d308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300f5ca9df6fdb12aab61f832e04d308">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">off_t zakero::MemoryPool::resize </td>
          <td>(</td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is similar to realloc(), in that it will resize the allocated memory at the given <code>offset</code>. If the resize was successful, the new offset will be returned.</p>
<p>The contents of the memory will be preserved.</p>
<p>The return value will be <code>-1</code> if the allocated memory could not be resized.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;Resizing in the Pool&quot;</span>);</div>
<div class="line"> </div>
<div class="line">memory_pool.init(128);</div>
<div class="line"> </div>
<div class="line">off_t offset = memory_pool.alloc(64);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do stuff with offset</span></div>
<div class="line"><span class="comment">// Oops, need more space</span></div>
<div class="line"> </div>
<div class="line">offset = memory_pool.resize(offset, 96);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The offset of the resized memory location. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The memory to resize </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2b52c606d65ae8ef344f59e1fee3713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b52c606d65ae8ef344f59e1fee3713">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">off_t zakero::MemoryPool::resize </td>
          <td>(</td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_condition &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is similar to realloc(), in that it will resize the allocated memory at the given <code>offset</code>. If the resize was successful, the new offset will be returned.</p>
<p>The contents of the memory will be preserved.</p>
<p>The return value will be <code>-1</code> if the allocated memory could not be resized and the reason will be stored in <code>error</code>.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;Resizing in the Pool&quot;</span>);</div>
<div class="line"> </div>
<div class="line">memory_pool.init(128);</div>
<div class="line"> </div>
<div class="line">off_t offset = memory_pool.alloc(64);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do stuff with offset</span></div>
<div class="line"><span class="comment">// Oops, need more space</span></div>
<div class="line"> </div>
<div class="line">std::error_codition error;</div>
<div class="line"><span class="keyword">auto</span> new_offset = memory_pool.resize(offset, 96, error);</div>
<div class="line"><span class="keywordflow">if</span>(error(<span class="keywordtype">bool</span>) == <span class="keyword">true</span>)</div>
<div class="line">{</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; error.message() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">        offset = new_offset;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The offset of the resized memory location. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The memory to resize </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes </td></tr>
    <tr><td class="paramname">error</td><td>The error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcdd1e2ac1a8bb8e4fb80eb9124d4c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdd1e2ac1a8bb8e4fb80eb9124d4c4d">&#9670;&nbsp;</a></span>addressOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * zakero::MemoryPool::addressOf </td>
          <td>(</td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The provided <code>offset</code> will be converted into an address that can be de-referenced as a normal C-Style pointer. If the <code>offset</code> is not valid, then <code>nullptr</code> will be returned.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line">off_t offset = memory_pool.alloc(256);</div>
<div class="line">uint8_t* ptr = memory_pool.addressOf(offset);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> expands and is relocated, the returned pointers will no longer be valid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzakero_1_1_memory_pool.html#adec529192bf00ca0ea535c4cbc81c082" title="Set the Remap Event callback.">onRemap()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An address </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adec529192bf00ca0ea535c4cbc81c082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec529192bf00ca0ea535c4cbc81c082">&#9670;&nbsp;</a></span>onRemap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zakero::MemoryPool::onRemap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classzakero_1_1_memory_pool.html#af684a6a80921ce92404f9f2d4bdb03ea">MemoryPool::LambdaAddressMap</a>&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>There are times when the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> will move allocated data. When this happens, the provided <code>lambda</code> will be called so that the caller will have an opportunity to update their pointers.</p>
<p>The lambda will receive a map of addresses where the key is the old address and the value is the new address.</p>
<p>If the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> was configured to be <em>not expandable</em> (see <a class="el" href="classzakero_1_1_memory_pool.html#a9dda3203fc80b7c711f74032a1b86157" title="Initialize the MemoryPool.">init()</a>), then the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> will never have a need to move it's region of memory. Therefore, the <code>lambda</code> will never be called and the pointers will never become invalid (unless the memory is freed).</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line">uint8_t* secret = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">memory_pool.onRemap([&amp;](<span class="keyword">const</span> <a class="code" href="classzakero_1_1_memory_pool.html#a5e9291872c2c7b3063a32d0a05408944">zakero::MemoryPool::AddressMap</a>&amp; map)</div>
<div class="line">{</div>
<div class="line">        secret = <a class="code" href="classzakero_1_1_memory_pool.html#ac79e330bb9ba2d1d21218f7b463cbfae">zakero::MemoryPool::remap</a>(map, secret);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">off_t secret_offset = memory_pool.alloc(512);</div>
<div class="line">secret = memory_pool.addressOf(secret_offset);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> will be in a "locked state" so any call from the lambda to a non-const <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> method will block indefinitely.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzakero_1_1_memory_pool.html#ac79e330bb9ba2d1d21218f7b463cbfae" title="Get the new memory address.">remap()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>The callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac79e330bb9ba2d1d21218f7b463cbfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79e330bb9ba2d1d21218f7b463cbfae">&#9670;&nbsp;</a></span>remap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * zakero::MemoryPool::remap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classzakero_1_1_memory_pool.html#a5e9291872c2c7b3063a32d0a05408944">MemoryPool::AddressMap</a> &amp;&#160;</td>
          <td class="paramname"><em>addr_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup the provided <code>address</code> in the <code>addr_map</code> and return the new address. If the <code>address</code> was not in the <code>addr_map</code>, the value of the <code>address</code> will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method whose only purpose is to improve the quality-of-life of the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> API.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzakero_1_1_memory_pool.html#adec529192bf00ca0ea535c4cbc81c082" title="Set the Remap Event callback.">onRemap()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A memory address. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr_map</td><td>A map of old/new addresses </td></tr>
    <tr><td class="paramname">address</td><td>An old memory address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b1c70a04bdfdb706989757e5d72c1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1c70a04bdfdb706989757e5d72c1cf">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zakero::MemoryPool::dump </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_per_character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>characters_per_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The internal state of the <a class="el" href="classzakero_1_1_memory_pool.html" title="A pool of memory.">MemoryPool</a> will be converted into a JSON formatted string. The JSON string will contain the following:</p><ul>
<li>The name of the anonymous file</li>
<li>The size of the memory pool</li>
<li>A list of segments and information about each segment</li>
<li>A layout of memory usage</li>
</ul>
<p>The content of the layout is controlled by the <code>bytes_per_character</code> and <code>characters_per_line</code> parameters.</p>
<p><b>Example</b><br  />
</p><div class="fragment"><div class="line"><a class="code" href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a> memory_pool(<span class="stringliteral">&quot;Dump It&quot;</span>);</div>
<div class="line"> </div>
<div class="line">memory_pool(512);</div>
<div class="line"> </div>
<div class="line">off_t o1 = memory_pool.alloc(64);</div>
<div class="line">off_t o2 = memory_pool.alloc(64);</div>
<div class="line">off_t o3 = memory_pool.alloc(128);</div>
<div class="line">off_t o4 = memory_pool.alloc(256);</div>
<div class="line">memory_pool.free(o2);</div>
<div class="line"> </div>
<div class="line">memory_pool.dump(1, 128);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The JSON formatted string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes_per_character</td><td>Used to determine how many allocated bytes are represented by each character in the layout. </td></tr>
    <tr><td class="paramname">characters_per_line</td><td>The length of each layout line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_zakero___memory_pool_8h_source.html">Zakero_MemoryPool.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasszakero_1_1_memory_pool_html_ac79e330bb9ba2d1d21218f7b463cbfae"><div class="ttname"><a href="classzakero_1_1_memory_pool.html#ac79e330bb9ba2d1d21218f7b463cbfae">zakero::MemoryPool::remap</a></div><div class="ttdeci">static uint8_t * remap(const MemoryPool::AddressMap &amp;, uint8_t *) noexcept</div><div class="ttdoc">Get the new memory address.</div><div class="ttdef"><b>Definition:</b> Zakero_MemoryPool.h:1154</div></div>
<div class="ttc" id="aclasszakero_1_1_memory_pool_html_a5e9291872c2c7b3063a32d0a05408944"><div class="ttname"><a href="classzakero_1_1_memory_pool.html#a5e9291872c2c7b3063a32d0a05408944">zakero::MemoryPool::AddressMap</a></div><div class="ttdeci">std::map&lt; uint8_t *, uint8_t * &gt; AddressMap</div><div class="ttdoc">A mapping of old addresses to new addresses.</div><div class="ttdef"><b>Definition:</b> Zakero_MemoryPool.h:234</div></div>
<div class="ttc" id="aclasszakero_1_1_memory_pool_html"><div class="ttname"><a href="classzakero_1_1_memory_pool.html">zakero::MemoryPool</a></div><div class="ttdoc">A pool of memory.</div><div class="ttdef"><b>Definition:</b> Zakero_MemoryPool.h:214</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
